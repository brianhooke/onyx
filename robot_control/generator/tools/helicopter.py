"""
Helicopter tool procedure generator.

Generates PROC Py2Heli() based on Andrew's HeliFCDummy pattern.
Key differences from HeliTrowelLR:
1. X coordinates are negated (Bed1Wyong coordinate system)
2. extax formula: Bed1Wyong.uframe.trans.x + trans.x + offset
3. NO ConfL\Off (this causes joint limit errors)
"""


def generate_py2heli(params: dict) -> str:
    """
    Generate PROC Py2Heli() RAPID code.
    
    Based on Andrew's working HeliFCDummy pattern:
    - Proper X negation for Bed1Wyong work object
    - Correct extax calculation
    - No ConfL\Off (avoids joint limit errors)
    
    Uses frontend parameters:
    - panel_datum_x, panel_datum_y: Start corner (near track)
    - panel_x, panel_y: Panel dimensions  
    - panel_z: Panel height
    - heli_travel_speed: Travel speed
    - heli_blade_speed: Blade RPM
    - heli_blade_angle: Blade angle (degrees)
    - heli_z_offset: Additional Z offset
    - helicopter_step: Step size between passes
    
    Returns:
        Complete PROC Py2Heli() as a string
    """
    # Extract parameters with defaults
    start_x = params.get('panel_datum_x', 1100)
    start_y = params.get('panel_datum_y', 600)
    panel_x = params.get('panel_x', 5900)
    panel_y = params.get('panel_y', 2200)
    # panel_z is now fixed at 150 (same as FormHeight in RAPID)
    global_z_offset = params.get('z_offset', 0)
    heli_z_offset = params.get('heli_z_offset', 0)
    total_z_offset = global_z_offset + heli_z_offset
    travel_speed = params.get('heli_travel_speed', 40)
    blade_speed = params.get('heli_blade_speed', 70)
    blade_angle = params.get('heli_blade_angle', 0)
    step_size = params.get('helicopter_step', 600)
    
    # Calculate end coordinates (far corner)
    end_x = start_x + panel_x
    end_y = start_y + panel_y
    
    # HeliBladeWidth constant (from baseline)
    blade_width = 600
    
    # Build the procedure - Cross-hatch pattern
    # Phase 1: X passes (sweep X, step Y)
    # Phase 2: Y passes (sweep Y, step X)
    # Key: X is NEGATED, extax = Bed1Wyong.uframe.trans.x + trans.x + offset
    proc = f'''
    PROC Py2Heli()
        ! Py2Heli - Cross-hatch pattern (Andrew's pattern base)
        ! Generated by Onyx Toolpath Generator v2
        ! Panel: ({start_x},{start_y}) to ({end_x},{end_y})
        ! Z = FormHeight(150) + z_offset({total_z_offset}) = {150 + total_z_offset}mm
        ! Step: {step_size}mm
        ! Pattern: X passes first, then Y passes
        
        VAR robtarget pStart;
        VAR robtarget pEnd;
        VAR robtarget pCurrent;
        VAR jointtarget CurrentJoints;
        VAR robtarget CurrentPos;
        VAR num WorkZ:=0;
        VAR num SafeZ:=0;
        VAR num CurrentY:=0;
        VAR num CurrentX:=0;
        VAR num MinY:=0;
        VAR num MaxY:=0;
        VAR num MinX:=0;
        VAR num MaxX:=0;
        VAR num StepSize:={step_size};
        VAR num SweepDir:=1;
        VAR num StepDir:=1;
        VAR num PassCount:=0;
        VAR num NextX:=0;
        VAR num StartY:=0;
        VAR num EndY:=0;
        VAR bool bDone:=FALSE;
        VAR speeddata vTravel:=[{travel_speed},15,2000,15];
        
        ! Initialize runtime values
        WorkZ:=FormHeight+{total_z_offset};
        SafeZ:=WorkZ+200;
        MinY:={start_y}+{blade_width}/2;
        MaxY:={end_y}-{blade_width}/2;
        MinX:={start_x}+{blade_width}/2;
        MaxX:={end_x}-{blade_width}/2;
        
        TPWrite "========================================";
        TPWrite "Py2Heli: Cross-hatch Starting";
        TPWrite "========================================";
        TPWrite "Panel X: " \\Num:={start_x};
        TPWrite " to X: " \\Num:={end_x};
        TPWrite "Panel Y: " \\Num:={start_y};
        TPWrite " to Y: " \\Num:={end_y};
        TPWrite "WorkZ=" \\Num:=WorkZ;
        TPWrite "SafeZ=" \\Num:=SafeZ;
        TPWrite "MinX=" \\Num:=MinX;
        TPWrite "MaxX=" \\Num:=MaxX;
        TPWrite "MinY=" \\Num:=MinY;
        TPWrite "MaxY=" \\Num:=MaxY;
        TPWrite "StepSize=" \\Num:=StepSize;
        
        ! Get helicopter if needed
        IF ToolNum<>2 THEN
            TPWrite "Py2Heli: Getting helicopter...";
            Home;
            Heli_Pickup;
        ENDIF
        
        ! ============================================
        ! PHASE 1: X PASSES (sweep X, step in Y)
        ! Start at far Y, work back toward track
        ! ============================================
        TPWrite "========================================";
        TPWrite "=== PHASE 1: X Passes ===";
        TPWrite "========================================";
        CurrentY:=MaxY;
        SweepDir:=1;
        PassCount:=0;
        TPWrite "P1: Starting at CurrentY=" \\Num:=CurrentY;
        TPWrite "P1: Will step toward MinY=" \\Num:=MinY;
        
        ! Initialize start position (X negated per Andrew's pattern)
        pStart.trans:=[-1*(MinX-100),CurrentY,WorkZ];
        pStart.rot:=OrientZYX(0,0,180);
        pStart.robconf:=[0,0,0,0];
        
        IF CurrentY<1800 THEN
            pStart.extax:=[Bed1Wyong.uframe.trans.x+pStart.trans.x+1000+{blade_width}/2,9E+09,9E+09,9E+09,9E+09,9E+09];
        ELSE
            pStart.extax:=[Bed1Wyong.uframe.trans.x+pStart.trans.x+{blade_width}/2,9E+09,9E+09,9E+09,9E+09,9E+09];
        ENDIF
        
        pEnd:=pStart;
        pEnd.trans.x:=-1*(MaxX+100);
        IF CurrentY<1800 THEN
            pEnd.extax.eax_a:=Bed1Wyong.uframe.trans.x+pEnd.trans.x+1000-{blade_width}/2;
        ELSE
            pEnd.extax.eax_a:=Bed1Wyong.uframe.trans.x+pEnd.trans.x-{blade_width}/2;
        ENDIF
        
        ! Move to start position (safe height)
        pStart.trans.z:=SafeZ;
        MoveJ pStart,v500,z5,tHeli\\WObj:=Bed1Wyong;
        
        ! Home stepper and set blade angle
        TPWrite "Py2Heli: Homing stepper...";
        Heli_Stepper_Home;
        HeliBlade_Angle {blade_angle};
        WaitTime 1;
        
        ! Disable configuration tracking for serpentine movements
        ConfL\\Off;
        ConfJ\\Off;
        
        ! Start blade rotation
        TPWrite "Py2Heli: Starting blade...";
        HeliBladeSpeed {blade_speed},"FWD";
        WaitTime 2;
        
        ! Lower to work height
        pStart.trans.z:=WorkZ;
        MoveJ Offs(pStart,0,0,50),v100,z5,tHeli\\WObj:=Bed1Wyong;
        MoveL pStart,v50,fine,tHeli\\WObj:=Bed1Wyong;
        
        TPWrite "P1: Entering X-pass loop...";
        bDone:=FALSE;
        
        ! X-pass serpentine loop (using flag instead of EXIT)
        WHILE CurrentY>=MinY AND bDone=FALSE DO
            Incr PassCount;
            TPWrite "----------------------------------------";
            TPWrite "P1: X Pass " \\Num:=PassCount;
            TPWrite "P1: CurrentY=" \\Num:=CurrentY;
            TPWrite "P1: SweepDir=" \\Num:=SweepDir;
            
            pStart.trans.y:=CurrentY;
            pEnd.trans.y:=CurrentY;
            
            IF CurrentY<1800 THEN
                pStart.extax.eax_a:=Bed1Wyong.uframe.trans.x+pStart.trans.x+1000+{blade_width}/2;
                pEnd.extax.eax_a:=Bed1Wyong.uframe.trans.x+pEnd.trans.x+1000-{blade_width}/2;
            ELSE
                pStart.extax.eax_a:=Bed1Wyong.uframe.trans.x+pStart.trans.x+{blade_width}/2;
                pEnd.extax.eax_a:=Bed1Wyong.uframe.trans.x+pEnd.trans.x-{blade_width}/2;
            ENDIF
            
            IF SweepDir=1 THEN
                TPWrite "P1: Sweep to pEnd (far X)";
                MoveL pEnd,vTravel,fine,tHeli\\WObj:=Bed1Wyong;
            ELSE
                TPWrite "P1: Sweep to pStart (near X)";
                MoveL pStart,vTravel,fine,tHeli\\WObj:=Bed1Wyong;
            ENDIF
            TPWrite "P1: Sweep complete";
            
            IF (CurrentY-StepSize)<MinY THEN
                TPWrite "P1: Last pass - (CurrentY-StepSize) < MinY";
                TPWrite "P1: Setting bDone=TRUE to exit loop";
                bDone:=TRUE;
            ELSE
                ! Only step to next row if not done
                CurrentY:=CurrentY-StepSize;
                TPWrite "P1: Step to next Y row=" \\Num:=CurrentY;
                
                IF SweepDir=1 THEN
                    pEnd.trans.y:=CurrentY;
                    IF CurrentY<1800 THEN
                        pEnd.extax.eax_a:=Bed1Wyong.uframe.trans.x+pEnd.trans.x+1000-{blade_width}/2;
                    ELSE
                        pEnd.extax.eax_a:=Bed1Wyong.uframe.trans.x+pEnd.trans.x-{blade_width}/2;
                    ENDIF
                    MoveL pEnd,vTravel,fine,tHeli\\WObj:=Bed1Wyong;
                ELSE
                    pStart.trans.y:=CurrentY;
                    IF CurrentY<1800 THEN
                        pStart.extax.eax_a:=Bed1Wyong.uframe.trans.x+pStart.trans.x+1000+{blade_width}/2;
                    ELSE
                        pStart.extax.eax_a:=Bed1Wyong.uframe.trans.x+pStart.trans.x+{blade_width}/2;
                    ENDIF
                    MoveL pStart,vTravel,fine,tHeli\\WObj:=Bed1Wyong;
                ENDIF
                
                SweepDir:=-1*SweepDir;
            ENDIF
        ENDWHILE
        
        TPWrite "P1: X passes complete, total=" \\Num:=PassCount;
        TPWrite "P1: Final position Y=" \\Num:=CurrentY;
        TPWrite "P1: pEnd.trans.x=" \\Num:=pEnd.trans.x;
        
        ! ============================================
        ! PHASE 2: Y PASSES (sweep Y, step in X)
        ! Continue from where Pass 1 ended (like baseline PyHeli)
        ! ============================================
        TPWrite "========================================";
        TPWrite "=== PHASE 2: Y Passes ===";
        TPWrite "========================================";
        
        ! Get current position from where X passes ended
        CurrentX:=Abs(pEnd.trans.x);
        TPWrite "Pass2: CurrentX=" \\Num:=CurrentX;
        TPWrite "Pass2: CurrentY=" \\Num:=CurrentY;
        
        ! Determine step direction based on where Pass 1 ended
        IF CurrentX>((MinX+MaxX)/2) THEN
            StepDir:=-1;
            TPWrite "Pass2: StepDir=-1";
        ELSE
            StepDir:=1;
            TPWrite "Pass2: StepDir=+1";
        ENDIF
        
        ! Determine sweep direction based on where Pass 1 ended
        IF CurrentY>((MinY+MaxY)/2) THEN
            SweepDir:=1;
            StartY:=MaxY;
            EndY:=MinY;
            TPWrite "P2: SweepDir=1 (toward MinY)";
        ELSE
            SweepDir:=-1;
            StartY:=MinY;
            EndY:=MaxY;
            TPWrite "P2: SweepDir=-1 (toward MaxY)";
        ENDIF
        TPWrite "P2: StartY=" \\Num:=StartY;
        TPWrite "P2: EndY=" \\Num:=EndY;
        
        PassCount:=0;
        
        ! First Y sweep from current position
        TPWrite "P2: First Y sweep to EndY=" \\Num:=EndY;
        pEnd.trans.y:=EndY;
        TPWrite "P2: Moving...";
        MoveL pEnd,vTravel,fine,tHeli\\WObj:=Bed1Wyong;
        TPWrite "P2: First Y sweep complete";
        
        TPWrite "P2: Entering Y-pass loop...";
        bDone:=FALSE;
        
        ! Y-pass loop - step in X, sweep in Y (using flag instead of EXIT)
        WHILE bDone=FALSE DO
            Incr PassCount;
            TPWrite "----------------------------------------";
            TPWrite "P2: Y Pass " \\Num:=PassCount;
            
            ! Calculate next column
            NextX:=CurrentX+(StepDir*StepSize);
            TPWrite "P2: CurrentX=" \\Num:=CurrentX;
            TPWrite "P2: NextX=" \\Num:=NextX;
            
            ! Check if complete
            IF (StepDir=1 AND NextX>MaxX) OR (StepDir=-1 AND NextX<MinX) THEN
                TPWrite "P2: NextX out of bounds - setting bDone=TRUE";
                bDone:=TRUE;
            ELSE
                ! Clamp to bounds
                IF NextX>MaxX THEN
                    NextX:=MaxX;
                    TPWrite "P2: Clamped to MaxX";
                ELSEIF NextX<MinX THEN
                    NextX:=MinX;
                    TPWrite "P2: Clamped to MinX";
                ENDIF
                
                ! Step to next X column
                TPWrite "P2: Step to X=" \\Num:=NextX;
                pEnd.trans.x:=-1*NextX;
                pEnd.extax.eax_a:=Bed1Wyong.uframe.trans.x-NextX;
                TPWrite "P2: Moving to next X column...";
                MoveL pEnd,vTravel,fine,tHeli\\WObj:=Bed1Wyong;
                TPWrite "P2: Step complete";
                CurrentX:=NextX;
                
                ! Flip sweep direction
                SweepDir:=-1*SweepDir;
                IF SweepDir=1 THEN
                    EndY:=MinY;
                    TPWrite "P2: Next sweep toward MinY=" \\Num:=EndY;
                ELSE
                    EndY:=MaxY;
                    TPWrite "P2: Next sweep toward MaxY=" \\Num:=EndY;
                ENDIF
                
                ! Sweep Y
                TPWrite "P2: Sweep to Y=" \\Num:=EndY;
                pEnd.trans.y:=EndY;
                TPWrite "P2: Moving...";
                MoveL pEnd,vTravel,fine,tHeli\\WObj:=Bed1Wyong;
                TPWrite "P2: Sweep complete";
            ENDIF
        ENDWHILE
        
        TPWrite "========================================";
        TPWrite "P2: Y passes complete, total=" \\Num:=PassCount;
        TPWrite "Cross-hatch complete!";
        TPWrite "========================================";
        
        ! ============================================
        ! FINISH: Stop blade, lift tool, return
        ! ============================================
        TPWrite "========================================";
        TPWrite "=== FINISH ===";
        TPWrite "========================================";
        
        TPWrite "FINISH: Stopping blade...";
        HeliBladeSpeed 0,"FWD";
        WaitTime 1;
        TPWrite "FINISH: Blade stopped";
        
        ! Lift off the bed
        TPWrite "FINISH: Lifting off bed...";
        CurrentJoints:=CJointT();
        CurrentPos:=CalcRobT(CurrentJoints,tHeli\\WObj:=Bed1Wyong);
        MoveJ Offs(CurrentPos,0,0,200),v100,fine,tHeli\\WObj:=Bed1Wyong;
        TPWrite "FINISH: Lifted 200mm";
        
        ! Re-enable configuration tracking
        TPWrite "FINISH: Re-enabling ConfL/ConfJ...";
        ConfL\\On;
        ConfJ\\On;
        TPWrite "FINISH: Configuration tracking enabled";
        
        ! Return tool
        TPWrite "FINISH: Dropping off helicopter...";
        Heli_Dropoff;
        TPWrite "FINISH: Helicopter dropped off";
        
        TPWrite "FINISH: Homing...";
        Home;
        
        TPWrite "========================================";
        TPWrite "Py2Heli: COMPLETE";
        TPWrite "========================================";
        
    ERROR
        HeliBladeSpeed 0,"FWD";
        RAISE;
    ENDPROC
'''
    return proc
