"""
Vacuum tool procedure generator.

Generates PROC Py2Vacuum() with cross-hatch pattern.
Key aspects:
1. Uses tVac tool (ToolNum = 5)
2. Cross-hatch pattern: X passes then Y passes
3. Bed1Wyong work object
4. Track position clamped to limits
"""

from .utils import get_track_limits


def generate_py2vacuum(params: dict) -> str:
    """
    Generate PROC Py2Vacuum() RAPID code.
    
    Cross-hatch pattern similar to helicopter:
    - Phase 1: X passes (sweep X, step Y)
    - Phase 2: Y passes (sweep Y, step X)
    
    Uses frontend parameters:
    - vacuum_workzone: 'bed' or 'panel'
    - vacuum_step: Step size between passes (mm)
    - vacuum_z_offset: Additional Z offset (mm)
    - vacuum_travel_speed: Travel speed (mm/s)
    - Panel/bed dimensions for workzone calculation
    
    Returns:
        Complete PROC Py2Vacuum() as a string
    """
    # Extract parameters with defaults (matches HTML form field names)
    workzone = params.get('vacuum_workzone', 'bed')
    step_size = params.get('vacuum_step', 300)
    global_z_offset = params.get('z_offset', 0)
    vacuum_z_offset = params.get('vacuum_z_offset', 0)
    total_z_offset = global_z_offset + vacuum_z_offset
    travel_speed = params.get('vacuum_speed', 200)
    
    # Calculate workzone boundaries based on selected workzone
    if workzone == 'panel':
        # Panel mode: use panel datum + dimensions
        start_x = params.get('panel_datum_x', 1100)
        start_y = params.get('panel_datum_y', 600)
        panel_x = params.get('panel_x', 5900)
        panel_y = params.get('panel_y', 2200)
        work_z = 150 + total_z_offset  # FormHeight + offset
    else:  # bed
        # Bed mode: use bed datum + dimensions
        start_x = params.get('bed_datum_x', 0)
        start_y = params.get('bed_datum_y', 0)
        panel_x = params.get('bed_length_x', 8500)
        panel_y = params.get('bed_width_y', 1650)
        work_z = total_z_offset  # Bed is at Z=0
    
    # Calculate end coordinates
    end_x = start_x + panel_x
    end_y = start_y + panel_y
    
    # Vacuum nozzle width for edge offsets
    nozzle_width = 400
    
    # Track limits (shared utility)
    track_min, track_max = get_track_limits(params)
    
    # Build the procedure - Cross-hatch pattern
    proc = f'''
    PROC Py2Vacuum()
        ! Py2Vacuum - Cross-hatch pattern for vacuum
        ! Generated by Onyx Toolpath Generator v2
        ! Workzone: {workzone}
        ! Area: ({start_x},{start_y}) to ({end_x},{end_y})
        ! Z = {work_z}mm
        ! Step: {step_size}mm
        ! Pattern: X passes first, then Y passes
        
        VAR robtarget pStart;
        VAR robtarget pEnd;
        VAR jointtarget CurrentJoints;
        VAR robtarget CurrentPos;
        VAR num WorkZ:=0;
        VAR num SafeZ:=0;
        VAR num CurrentY:=0;
        VAR num CurrentX:=0;
        VAR num MinY:=0;
        VAR num MaxY:=0;
        VAR num MinX:=0;
        VAR num MaxX:=0;
        VAR num StepSize:={step_size};
        VAR num SweepDir:=1;
        VAR num StepDir:=1;
        VAR num PassCount:=0;
        VAR num NextX:=0;
        VAR num StartY:=0;
        VAR num EndY:=0;
        VAR bool bDone:=FALSE;
        VAR speeddata vTravel:=[{travel_speed},15,2000,15];
        VAR num TrackMin:={track_min};
        VAR num TrackMax:={track_max};
        VAR num CalcTrack:=0;
        
        ! Initialize runtime values
        WorkZ:={work_z};
        SafeZ:=WorkZ+200;
        MinY:={start_y}+{nozzle_width}/2;
        MaxY:={end_y}-{nozzle_width}/2;
        MinX:={start_x}+{nozzle_width}/2;
        MaxX:={end_x}-{nozzle_width}/2;
        
        TPWrite "========================================";
        TPWrite "Py2Vacuum: Cross-hatch Starting";
        TPWrite "========================================";
        TPWrite "Workzone: {workzone}";
        TPWrite "MinX=" \\Num:=MinX;
        TPWrite "MaxX=" \\Num:=MaxX;
        TPWrite "MinY=" \\Num:=MinY;
        TPWrite "MaxY=" \\Num:=MaxY;
        TPWrite "WorkZ=" \\Num:=WorkZ;
        TPWrite "StepSize=" \\Num:=StepSize;
        
        ! Get vacuum if needed
        IF ToolNum<>5 THEN
            TPWrite "Py2Vacuum: Getting vacuum...";
            Home;
            Vac_Pickup;
        ELSE
            ! Already have vacuum - ensure safe height
            CurrentJoints:=CJointT();
            CurrentPos:=CalcRobT(CurrentJoints,tVac\\WObj:=Bed1Wyong);
            IF CurrentPos.trans.z<600 THEN
                MoveL Offs(CurrentPos,0,0,(600-CurrentPos.trans.z)),v500,z5,tVac\\WObj:=Bed1Wyong;
            ENDIF
        ENDIF
        
        ! ============================================
        ! PHASE 1: X PASSES (sweep X, step in Y)
        ! Start at far Y (MaxY), work back toward track
        ! ============================================
        TPWrite "P1: Starting X passes...";
        CurrentY:=MaxY;
        SweepDir:=1;
        PassCount:=0;
        TPWrite "P1: Starting at CurrentY=" \\Num:=CurrentY;
        
        ! Initialize start position (X negated per Bed1Wyong)
        pStart.trans:=[-1*(MinX-100),CurrentY,WorkZ];
        pStart.rot:=OrientZYX(0,0,180);
        pStart.robconf:=[0,0,0,0];
        
        ! Clamp track position
        CalcTrack:=Bed1Wyong.uframe.trans.x+pStart.trans.x+{nozzle_width}/2;
        IF CalcTrack<TrackMin THEN CalcTrack:=TrackMin; ENDIF
        IF CalcTrack>TrackMax THEN CalcTrack:=TrackMax; ENDIF
        pStart.extax:=[CalcTrack,9E+09,9E+09,9E+09,9E+09,9E+09];
        
        pEnd:=pStart;
        pEnd.trans.x:=-1*(MaxX+100);
        CalcTrack:=Bed1Wyong.uframe.trans.x+pEnd.trans.x-{nozzle_width}/2;
        IF CalcTrack<TrackMin THEN CalcTrack:=TrackMin; ENDIF
        IF CalcTrack>TrackMax THEN CalcTrack:=TrackMax; ENDIF
        pEnd.extax.eax_a:=CalcTrack;
        
        ! Move to start position (safe height)
        pStart.trans.z:=SafeZ;
        MoveJ pStart,v500,z5,tVac\\WObj:=Bed1Wyong;
        
        ! Disable configuration tracking
        ConfL\\Off;
        ConfJ\\Off;
        
        ! Turn on vacuum
        TPWrite "Py2Vacuum: Starting vacuum...";
        Vac_on;
        WaitTime 1;
        
        ! Lower to work height
        pStart.trans.z:=WorkZ;
        pEnd.trans.z:=WorkZ;
        MoveJ Offs(pStart,0,0,50),v100,z5,tVac\\WObj:=Bed1Wyong;
        MoveL pStart,v50,fine,tVac\\WObj:=Bed1Wyong;
        
        TPWrite "P1: Entering X-pass loop...";
        bDone:=FALSE;
        
        ! X-pass loop
        WHILE CurrentY>=MinY AND bDone=FALSE DO
            Incr PassCount;
            TPWrite "----------------------------------------";
            TPWrite "P1: X Pass " \\Num:=PassCount;
            TPWrite "P1: CurrentY=" \\Num:=CurrentY;
            
            pStart.trans.y:=CurrentY;
            pEnd.trans.y:=CurrentY;
            
            ! Update extax with clamping
            CalcTrack:=Bed1Wyong.uframe.trans.x+pStart.trans.x+{nozzle_width}/2;
            IF CalcTrack<TrackMin THEN CalcTrack:=TrackMin; ENDIF
            IF CalcTrack>TrackMax THEN CalcTrack:=TrackMax; ENDIF
            pStart.extax.eax_a:=CalcTrack;
            
            CalcTrack:=Bed1Wyong.uframe.trans.x+pEnd.trans.x-{nozzle_width}/2;
            IF CalcTrack<TrackMin THEN CalcTrack:=TrackMin; ENDIF
            IF CalcTrack>TrackMax THEN CalcTrack:=TrackMax; ENDIF
            pEnd.extax.eax_a:=CalcTrack;
            
            IF SweepDir=1 THEN
                TPWrite "P1: Sweep to pEnd (far X)";
                MoveL pEnd,vTravel,fine,tVac\\WObj:=Bed1Wyong;
            ELSE
                TPWrite "P1: Sweep to pStart (near X)";
                MoveL pStart,vTravel,fine,tVac\\WObj:=Bed1Wyong;
            ENDIF
            
            IF (CurrentY-StepSize)<MinY THEN
                TPWrite "P1: Last pass - setting bDone=TRUE";
                bDone:=TRUE;
            ELSE
                ! Step to next row
                CurrentY:=CurrentY-StepSize;
                TPWrite "P1: Step to next Y row=" \\Num:=CurrentY;
                
                IF SweepDir=1 THEN
                    pEnd.trans.y:=CurrentY;
                    CalcTrack:=Bed1Wyong.uframe.trans.x+pEnd.trans.x-{nozzle_width}/2;
                    IF CalcTrack<TrackMin THEN CalcTrack:=TrackMin; ENDIF
                    IF CalcTrack>TrackMax THEN CalcTrack:=TrackMax; ENDIF
                    pEnd.extax.eax_a:=CalcTrack;
                    MoveL pEnd,vTravel,fine,tVac\\WObj:=Bed1Wyong;
                ELSE
                    pStart.trans.y:=CurrentY;
                    CalcTrack:=Bed1Wyong.uframe.trans.x+pStart.trans.x+{nozzle_width}/2;
                    IF CalcTrack<TrackMin THEN CalcTrack:=TrackMin; ENDIF
                    IF CalcTrack>TrackMax THEN CalcTrack:=TrackMax; ENDIF
                    pStart.extax.eax_a:=CalcTrack;
                    MoveL pStart,vTravel,fine,tVac\\WObj:=Bed1Wyong;
                ENDIF
                
                SweepDir:=-1*SweepDir;
            ENDIF
        ENDWHILE
        
        TPWrite "P1: X passes complete, total=" \\Num:=PassCount;
        
        ! ============================================
        ! PHASE 2: Y PASSES (sweep Y, step in X)
        ! Start at current X position, sweep in Y
        ! ============================================
        TPWrite "P2: Starting Y passes...";
        
        ! Reset for Y passes - start from MinX
        CurrentX:=MinX;
        StepDir:=1;
        PassCount:=0;
        bDone:=FALSE;
        
        ! Determine sweep direction based on where we ended Phase 1
        IF SweepDir=1 THEN
            StartY:=MinY;
            EndY:=MaxY;
        ELSE
            StartY:=MaxY;
            EndY:=MinY;
        ENDIF
        
        ! Initialize position for Y sweeps
        pStart.trans:=[-1*CurrentX,StartY,WorkZ];
        pEnd.trans:=[-1*CurrentX,EndY,WorkZ];
        
        CalcTrack:=Bed1Wyong.uframe.trans.x-CurrentX;
        IF CalcTrack<TrackMin THEN CalcTrack:=TrackMin; ENDIF
        IF CalcTrack>TrackMax THEN CalcTrack:=TrackMax; ENDIF
        pStart.extax.eax_a:=CalcTrack;
        pEnd.extax.eax_a:=CalcTrack;
        
        TPWrite "P2: Starting at X=" \\Num:=CurrentX;
        TPWrite "P2: StartY=" \\Num:=StartY;
        TPWrite "P2: EndY=" \\Num:=EndY;
        
        ! Y-pass loop
        WHILE bDone=FALSE DO
            Incr PassCount;
            TPWrite "----------------------------------------";
            TPWrite "P2: Y Pass " \\Num:=PassCount;
            TPWrite "P2: CurrentX=" \\Num:=CurrentX;
            
            ! Sweep in Y direction
            IF SweepDir=1 THEN
                TPWrite "P2: Sweep toward MaxY";
                MoveL pEnd,vTravel,fine,tVac\\WObj:=Bed1Wyong;
            ELSE
                TPWrite "P2: Sweep toward MinY";
                MoveL pStart,vTravel,fine,tVac\\WObj:=Bed1Wyong;
            ENDIF
            
            ! Calculate next X position
            NextX:=CurrentX+(StepDir*StepSize);
            
            ! Check if complete
            IF (StepDir=1 AND NextX>MaxX) OR (StepDir=-1 AND NextX<MinX) THEN
                TPWrite "P2: NextX out of bounds - setting bDone=TRUE";
                bDone:=TRUE;
            ELSE
                ! Clamp to bounds
                IF NextX>MaxX THEN
                    NextX:=MaxX;
                ELSEIF NextX<MinX THEN
                    NextX:=MinX;
                ENDIF
                
                ! Step to next X column
                TPWrite "P2: Step to X=" \\Num:=NextX;
                pEnd.trans.x:=-1*NextX;
                pStart.trans.x:=-1*NextX;
                CalcTrack:=Bed1Wyong.uframe.trans.x-NextX;
                IF CalcTrack<TrackMin THEN CalcTrack:=TrackMin; ENDIF
                IF CalcTrack>TrackMax THEN CalcTrack:=TrackMax; ENDIF
                pEnd.extax.eax_a:=CalcTrack;
                pStart.extax.eax_a:=CalcTrack;
                
                IF SweepDir=1 THEN
                    MoveL pEnd,vTravel,fine,tVac\\WObj:=Bed1Wyong;
                ELSE
                    MoveL pStart,vTravel,fine,tVac\\WObj:=Bed1Wyong;
                ENDIF
                
                CurrentX:=NextX;
                SweepDir:=-1*SweepDir;
            ENDIF
        ENDWHILE
        
        TPWrite "P2: Y passes complete, total=" \\Num:=PassCount;
        
        ! ============================================
        ! FINISH: Turn off vacuum, raise, dropoff
        ! ============================================
        TPWrite "========================================";
        TPWrite "Py2Vacuum: Complete";
        TPWrite "========================================";
        
        ! Turn off vacuum
        Vac_off;
        
        ! Raise to safe height
        CurrentJoints:=CJointT();
        CurrentPos:=CalcRobT(CurrentJoints,tVac\\WObj:=Bed1Wyong);
        MoveL Offs(CurrentPos,0,0,200),v200,z5,tVac\\WObj:=Bed1Wyong;
        
        ! Re-enable config tracking
        ConfL\\On;
        ConfJ\\On;
        
        ! Return tool and go home
        TPWrite "Py2Vacuum: Dropping off vacuum...";
        Vac_Dropoff;
        TPWrite "Py2Vacuum: Vacuum dropped off";
        
        TPWrite "Py2Vacuum: Homing...";
        Home;
        
        TPWrite "========================================";
        TPWrite "Py2Vacuum: COMPLETE";
        TPWrite "========================================";
        
    ERROR
        Vac_off;
        TPWrite "Py2Vacuum ERROR: " \\Num:=ERRNO;
        RAISE;
    ENDPROC
'''
    return proc
