<!-- Tool Demos - Bed & Panel Visualization Component -->
<!-- Included by toolpath_generator_compact.html -->

<!-- Bed & Panel Visualization -->
<div id="bed-visualization" class="card p-2">
    <div class="flex items-center justify-between mb-1">
        <h3 class="text-xs font-medium text-gray-600">Bed & Panel Preview</h3>
        <span class="text-[10px] text-gray-500">Units: mm</span>
    </div>
    <div class="flex gap-2">
        <!-- Tool list with demo buttons -->
        <div class="flex flex-col gap-2 text-sm min-w-[180px]">
            <div class="flex items-center justify-between gap-2">
                <span class="text-blue-600 font-medium">Vacuum</span>
                <button type="button" data-tool="vacuum" class="demo-btn px-2 py-1 bg-gray-100 hover:bg-gray-200 rounded text-gray-600 text-xs border border-gray-200">demo</button>
            </div>
            <div class="flex items-center justify-between gap-2">
                <span class="text-green-600 font-medium">Polisher</span>
                <button type="button" data-tool="polisher" class="demo-btn px-2 py-1 bg-gray-100 hover:bg-gray-200 rounded text-gray-600 text-xs border border-gray-200">demo</button>
            </div>
            <div class="flex items-center justify-between gap-2">
                <span class="text-purple-600 font-medium">Helicopter</span>
                <button type="button" data-tool="helicopter" class="demo-btn px-2 py-1 bg-gray-100 hover:bg-gray-200 rounded text-gray-600 text-xs border border-gray-200">demo</button>
            </div>
            <div class="flex items-center justify-between gap-2">
                <span class="text-orange-600 font-medium">Pan</span>
                <button type="button" data-tool="pan" class="demo-btn px-2 py-1 bg-gray-100 hover:bg-gray-200 rounded text-gray-600 text-xs border border-gray-200">demo</button>
            </div>
            <div class="flex items-center justify-between gap-2">
                <span class="text-amber-600 font-medium">Screed</span>
                <button type="button" data-tool="screed" class="demo-btn px-2 py-1 bg-gray-100 hover:bg-gray-200 rounded text-gray-600 text-xs border border-gray-200">demo</button>
            </div>
            <div class="flex items-center justify-between gap-2">
                <span class="text-rose-600 font-medium">Trowel</span>
                <button type="button" data-tool="trowel" class="demo-btn px-2 py-1 bg-gray-100 hover:bg-gray-200 rounded text-gray-600 text-xs border border-gray-200">demo</button>
            </div>
            <!-- Legend -->
            <div class="mt-2 pt-2 border-t border-gray-200 flex flex-col gap-1">
                <div class="flex items-center gap-2">
                    <div class="w-4 h-3 rounded-sm" style="background: #1e3a5f; border: 1px solid #3b82f6;"></div>
                    <span class="text-xs text-gray-500">Bed</span>
                </div>
                <div class="flex items-center gap-2">
                    <div class="w-4 h-3 rounded-sm" style="background: #ffffff; border: 1px solid #9ca3af;"></div>
                    <span class="text-xs text-gray-500">Panel</span>
                </div>
            </div>
        </div>
        <!-- SVG visualization -->
        <div class="flex-1 bg-gray-100 rounded overflow-hidden border border-gray-200">
            <svg id="bed-svg" class="w-full" style="height: 400px;" viewBox="0 0 750 400">
                <g id="bed-group">
                    <polygon id="bed-side-back" fill="#0f2540" stroke="#2563eb" stroke-width="1"/>
                    <polygon id="bed-side-left" fill="#162d4a" stroke="#2563eb" stroke-width="1"/>
                    <polygon id="bed-side-front" fill="#0f2540" stroke="#2563eb" stroke-width="1"/>
                    <polygon id="bed-side-right" fill="#162d4a" stroke="#2563eb" stroke-width="1"/>
                    <polygon id="bed-top" fill="#1e3a5f" stroke="#3b82f6" stroke-width="1"/>
                </g>
                <g id="panel-group">
                    <polygon id="panel-side-back" fill="#d1d5db" stroke="#9ca3af" stroke-width="1"/>
                    <polygon id="panel-side-left" fill="#e5e7eb" stroke="#9ca3af" stroke-width="1"/>
                    <polygon id="panel-side-front" fill="#d1d5db" stroke="#9ca3af" stroke-width="1"/>
                    <polygon id="panel-side-right" fill="#e5e7eb" stroke="#9ca3af" stroke-width="1"/>
                    <polygon id="panel-top" fill="#ffffff" stroke="#9ca3af" stroke-width="1"/>
                </g>
                <g id="coverage-trail"></g>
                <g id="pattern-path"></g>
                <g id="tool-circle"></g>
                <g id="pattern-overlay"></g>
                <g id="axis-labels"></g>
                <g id="dimension-labels"></g>
            </svg>
        </div>
        <!-- Metrics column -->
        <div class="flex flex-col gap-3 min-w-[200px] text-sm">
            <div class="text-gray-600 font-medium text-sm border-b border-gray-200 pb-1">Metrics</div>
            <div class="flex flex-col gap-1">
                <span class="text-xs text-gray-500">Active Tool</span>
                <span id="demo-tool-name" class="font-medium text-gray-900 text-base">—</span>
            </div>
            <div class="flex flex-col gap-1">
                <span class="text-xs text-gray-500">Duration</span>
                <span id="demo-duration" class="text-gray-700">—</span>
            </div>
            <!-- Timeline slider -->
            <div id="demo-timeline" class="mt-2 hidden">
                <div class="flex items-center gap-2">
                    <button id="demo-play-btn" class="px-2 py-1 bg-gray-100 hover:bg-gray-200 rounded text-xs text-gray-600 border border-gray-200">
                        <span id="play-icon">▶</span>
                    </button>
                    <input type="range" id="demo-slider" min="0" max="1000" value="0" class="flex-1 h-2 bg-gray-200 rounded appearance-none cursor-pointer">
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Force Monitoring Display -->
<div id="force-monitor" class="card p-2 mt-2">
    <div class="flex items-center justify-between mb-2">
        <h3 class="text-xs font-medium text-gray-600">Force Monitor (6-Axis)</h3>
        <div class="flex items-center gap-2">
            <span id="force-status" class="text-[10px] text-gray-400">Disconnected</span>
            <button type="button" id="force-live-btn" class="px-2 py-0.5 bg-blue-100 hover:bg-blue-200 rounded text-[10px] text-blue-600 border border-blue-200">Live Forces</button>
            <button type="button" id="force-connect-btn" class="px-2 py-0.5 bg-gray-100 hover:bg-gray-200 rounded text-[10px] text-gray-600 border border-gray-200">Connect</button>
        </div>
    </div>
    <div class="grid grid-cols-6 gap-2">
        <!-- Force X -->
        <div class="flex flex-col items-center p-2 bg-gray-50 rounded border border-gray-200">
            <span class="text-[10px] text-gray-500 mb-1">Force X</span>
            <div class="relative w-full h-16 bg-gray-200 rounded overflow-hidden">
                <div id="force-x-bar" class="absolute bottom-0 left-0 right-0 bg-blue-500 transition-all" style="height: 50%;"></div>
                <div class="absolute inset-0 flex items-center justify-center">
                    <span id="force-x-val" class="text-xs font-bold text-gray-800">0</span>
                </div>
            </div>
            <span class="text-[10px] text-gray-400 mt-1">N</span>
        </div>
        <!-- Force Y -->
        <div class="flex flex-col items-center p-2 bg-gray-50 rounded border border-gray-200">
            <span class="text-[10px] text-gray-500 mb-1">Force Y</span>
            <div class="relative w-full h-16 bg-gray-200 rounded overflow-hidden">
                <div id="force-y-bar" class="absolute bottom-0 left-0 right-0 bg-green-500 transition-all" style="height: 50%;"></div>
                <div class="absolute inset-0 flex items-center justify-center">
                    <span id="force-y-val" class="text-xs font-bold text-gray-800">0</span>
                </div>
            </div>
            <span class="text-[10px] text-gray-400 mt-1">N</span>
        </div>
        <!-- Force Z -->
        <div class="flex flex-col items-center p-2 bg-gray-50 rounded border border-gray-200">
            <span class="text-[10px] text-gray-500 mb-1">Force Z</span>
            <div class="relative w-full h-16 bg-gray-200 rounded overflow-hidden">
                <div id="force-z-bar" class="absolute bottom-0 left-0 right-0 bg-purple-500 transition-all" style="height: 50%;"></div>
                <div class="absolute inset-0 flex items-center justify-center">
                    <span id="force-z-val" class="text-xs font-bold text-gray-800">0</span>
                </div>
            </div>
            <span class="text-[10px] text-gray-400 mt-1">N</span>
        </div>
        <!-- Torque X -->
        <div class="flex flex-col items-center p-2 bg-gray-50 rounded border border-gray-200">
            <span class="text-[10px] text-gray-500 mb-1">Torque X</span>
            <div class="relative w-full h-16 bg-gray-200 rounded overflow-hidden">
                <div id="force-tx-bar" class="absolute bottom-0 left-0 right-0 bg-orange-500 transition-all" style="height: 50%;"></div>
                <div class="absolute inset-0 flex items-center justify-center">
                    <span id="force-tx-val" class="text-xs font-bold text-gray-800">0</span>
                </div>
            </div>
            <span class="text-[10px] text-gray-400 mt-1">Nm</span>
        </div>
        <!-- Torque Y -->
        <div class="flex flex-col items-center p-2 bg-gray-50 rounded border border-gray-200">
            <span class="text-[10px] text-gray-500 mb-1">Torque Y</span>
            <div class="relative w-full h-16 bg-gray-200 rounded overflow-hidden">
                <div id="force-ty-bar" class="absolute bottom-0 left-0 right-0 bg-pink-500 transition-all" style="height: 50%;"></div>
                <div class="absolute inset-0 flex items-center justify-center">
                    <span id="force-ty-val" class="text-xs font-bold text-gray-800">0</span>
                </div>
            </div>
            <span class="text-[10px] text-gray-400 mt-1">Nm</span>
        </div>
        <!-- Torque Z -->
        <div class="flex flex-col items-center p-2 bg-gray-50 rounded border border-gray-200">
            <span class="text-[10px] text-gray-500 mb-1">Torque Z</span>
            <div class="relative w-full h-16 bg-gray-200 rounded overflow-hidden">
                <div id="force-tz-bar" class="absolute bottom-0 left-0 right-0 bg-cyan-500 transition-all" style="height: 50%;"></div>
                <div class="absolute inset-0 flex items-center justify-center">
                    <span id="force-tz-val" class="text-xs font-bold text-gray-800">0</span>
                </div>
            </div>
            <span class="text-[10px] text-gray-400 mt-1">Nm</span>
        </div>
    </div>
    <!-- Force History Graph (mini sparkline) -->
    <div class="mt-2 pt-2 border-t border-gray-200">
        <div class="flex items-center justify-between mb-1">
            <span class="text-[10px] text-gray-500">Force Z History</span>
            <span id="force-z-peak" class="text-[10px] text-gray-400">Peak: 0N</span>
        </div>
        <div class="h-8 bg-gray-100 rounded border border-gray-200 overflow-hidden">
            <svg id="force-history-svg" class="w-full h-full" preserveAspectRatio="none">
                <polyline id="force-history-line" fill="none" stroke="#8b5cf6" stroke-width="1.5" points=""/>
            </svg>
        </div>
    </div>
</div>

<script>
// =============================================================================
// Force Monitor - Real-time 6-axis force display
// =============================================================================

let forceMonitorState = {
    connected: false,
    polling: false,
    pollInterval: null,
    history: [],
    maxHistory: 100,
    peakForceZ: 0,
    maxForce: 500,  // Max scale for bar display (N)
    maxTorque: 50,  // Max scale for torque display (Nm)
};

function setupForceMonitor() {
    const connectBtn = document.getElementById('force-connect-btn');
    if (connectBtn) {
        connectBtn.addEventListener('click', toggleForceMonitor);
    }
    
    const liveBtn = document.getElementById('force-live-btn');
    if (liveBtn) {
        liveBtn.addEventListener('click', startLiveForces);
    }
}

async function startLiveForces() {
    const btn = document.getElementById('force-live-btn');
    const statusEl = document.getElementById('force-status');
    
    if (btn) btn.textContent = 'Starting...';
    if (btn) btn.disabled = true;
    
    try {
        const response = await fetch('/api/irc5/start-force-monitor/', { method: 'POST' });
        const data = await response.json();
        
        if (data.success) {
            if (statusEl) statusEl.textContent = 'force_monitor() started';
            if (btn) btn.textContent = 'Running';
            // Auto-start polling
            if (!forceMonitorState.polling) {
                startForceMonitor();
            }
        } else {
            if (statusEl) statusEl.textContent = 'Error: ' + (data.error || 'Failed');
            if (btn) btn.textContent = 'Live Forces';
            if (btn) btn.disabled = false;
        }
    } catch (err) {
        if (statusEl) statusEl.textContent = 'Error: ' + err.message;
        if (btn) btn.textContent = 'Live Forces';
        if (btn) btn.disabled = false;
    }
}

function toggleForceMonitor() {
    if (forceMonitorState.polling) {
        stopForceMonitor();
    } else {
        startForceMonitor();
    }
}

function startForceMonitor() {
    forceMonitorState.polling = true;
    forceMonitorState.history = [];
    forceMonitorState.peakForceZ = 0;
    
    const statusEl = document.getElementById('force-status');
    const btnEl = document.getElementById('force-connect-btn');
    if (statusEl) statusEl.textContent = 'Connecting...';
    if (btnEl) btnEl.textContent = 'Stop';
    
    // Poll every 100ms (10Hz) - IRC5 updates at 10ms but network latency limits us
    forceMonitorState.pollInterval = setInterval(pollForceData, 100);
}

function stopForceMonitor() {
    forceMonitorState.polling = false;
    if (forceMonitorState.pollInterval) {
        clearInterval(forceMonitorState.pollInterval);
        forceMonitorState.pollInterval = null;
    }
    
    const statusEl = document.getElementById('force-status');
    const btnEl = document.getElementById('force-connect-btn');
    if (statusEl) statusEl.textContent = 'Disconnected';
    if (btnEl) btnEl.textContent = 'Connect';
}

async function pollForceData() {
    try {
        const response = await fetch('/api/irc5/force-data/');
        const data = await response.json();
        
        if (data.success) {
            forceMonitorState.connected = true;
            updateForceDisplay(data.forces);
            
            const statusEl = document.getElementById('force-status');
            if (data.source === 'rapid_pers') {
                // Live feed from force_monitor()
                if (statusEl) statusEl.textContent = 'Live';
                statusEl.className = 'text-[10px] text-green-500';
            } else if (data.errors && data.errors.length > 0) {
                // AO signals missing
                if (statusEl) statusEl.textContent = 'AO missing';
                statusEl.className = 'text-[10px] text-yellow-500';
                statusEl.title = data.note || data.errors.join(', ');
            } else {
                // AO signals working but not live
                if (statusEl) statusEl.textContent = 'Static (run force_monitor)';
                statusEl.className = 'text-[10px] text-yellow-500';
            }
        } else {
            const statusEl = document.getElementById('force-status');
            if (statusEl) statusEl.textContent = 'Error: ' + (data.error || 'Unknown');
            statusEl.className = 'text-[10px] text-red-400';
        }
    } catch (err) {
        const statusEl = document.getElementById('force-status');
        if (statusEl) statusEl.textContent = 'Connection failed';
        statusEl.className = 'text-[10px] text-red-400';
    }
}

function updateForceDisplay(forces) {
    // Update bar charts and values
    const axes = ['x', 'y', 'z', 'tx', 'ty', 'tz'];
    const maxValues = {
        x: forceMonitorState.maxForce,
        y: forceMonitorState.maxForce,
        z: forceMonitorState.maxForce,
        tx: forceMonitorState.maxTorque,
        ty: forceMonitorState.maxTorque,
        tz: forceMonitorState.maxTorque,
    };
    
    axes.forEach(axis => {
        const value = forces[axis] || 0;
        const max = maxValues[axis];
        const percentage = Math.min(Math.abs(value) / max * 100, 100);
        
        const barEl = document.getElementById(`force-${axis}-bar`);
        const valEl = document.getElementById(`force-${axis}-val`);
        
        if (barEl) barEl.style.height = `${percentage}%`;
        if (valEl) valEl.textContent = value.toFixed(1);
        
        // Color coding: green for low, yellow for medium, red for high
        if (barEl) {
            if (percentage > 80) {
                barEl.classList.remove('bg-blue-500', 'bg-green-500', 'bg-purple-500', 'bg-orange-500', 'bg-pink-500', 'bg-cyan-500', 'bg-yellow-500');
                barEl.classList.add('bg-red-500');
            } else if (percentage > 50) {
                barEl.classList.remove('bg-red-500');
                barEl.classList.add('bg-yellow-500');
            }
        }
    });
    
    // Update history for Force Z
    const forceZ = forces.z || 0;
    forceMonitorState.history.push(forceZ);
    if (forceMonitorState.history.length > forceMonitorState.maxHistory) {
        forceMonitorState.history.shift();
    }
    
    // Track peak
    if (Math.abs(forceZ) > Math.abs(forceMonitorState.peakForceZ)) {
        forceMonitorState.peakForceZ = forceZ;
        const peakEl = document.getElementById('force-z-peak');
        if (peakEl) peakEl.textContent = `Peak: ${forceZ.toFixed(1)}N`;
    }
    
    // Update sparkline
    updateForceHistoryGraph();
}

function updateForceHistoryGraph() {
    const svg = document.getElementById('force-history-svg');
    const line = document.getElementById('force-history-line');
    if (!svg || !line) return;
    
    const history = forceMonitorState.history;
    if (history.length < 2) return;
    
    const width = svg.clientWidth || 200;
    const height = svg.clientHeight || 32;
    const maxVal = forceMonitorState.maxForce;
    
    const points = history.map((val, i) => {
        const x = (i / (forceMonitorState.maxHistory - 1)) * width;
        const y = height - ((val + maxVal) / (2 * maxVal)) * height;  // Center at 0
        return `${x},${y}`;
    }).join(' ');
    
    line.setAttribute('points', points);
}

// Initialize on DOM ready
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', setupForceMonitor);
} else {
    setupForceMonitor();
}
</script>

<script>
// =============================================================================
// Tool Demos - Bed & Panel Visualization
// =============================================================================

function setupBedVisualization() {
    const svg = document.getElementById('bed-svg');
    const axisLabels = document.getElementById('axis-labels');
    const dimensionLabels = document.getElementById('dimension-labels');
    
    if (!svg) return;
    
    const svgWidth = 750;
    const svgHeight = 400;
    const margin = { top: 20, right: 20, bottom: 20, left: 20 };
    const plotWidth = svgWidth - margin.left - margin.right;
    const plotHeight = svgHeight - margin.top - margin.bottom;
    
    // Isometric projection constants
    // X axis goes upper-left, Y axis goes upper-right, Z goes straight up
    // Viewing from front-right at ~45° elevation
    const ISO_COS = Math.cos(Math.PI / 6); // 0.866 - horizontal spread
    const ISO_SIN = Math.sin(Math.PI / 6); // 0.5 - vertical component
    const BED_THICKNESS = 280; // Bed height (mm)
    const LIFT_HEIGHT = 250; // Tool lift height above work surface (mm)
    
    // View rotation angle around Z axis (degrees, modified by mouse drag)
    let viewAngle = 0;
    
    function updateVisualization() {
        const getVal = (name, def) => {
            const el = document.querySelector(`input[name="${name}"]`);
            const v = el ? parseFloat(el.value) : NaN;
            return isNaN(v) ? def : v;
        };
        const bedLengthX = getVal('bed_length_x', 12000);
        const bedWidthY = getVal('bed_width_y', 3300);
        const panelX = getVal('panel_x', 3000);
        const panelY = getVal('panel_y', 2000);
        const panelDatumX = getVal('panel_datum_x', 0);
        const panelDatumY = getVal('panel_datum_y', 0);
        const panelZHeight = getVal('panel_z', 150); // Panel thickness from form input
        
        // View rotation: rotate world coords around Z axis before projecting
        const va_rad = viewAngle * Math.PI / 180;
        const cosVA = Math.cos(va_rad);
        const sinVA = Math.sin(va_rad);
        
        // Compute bounding box of isometric projection at current viewAngle
        const bedCorners = [[0,0], [bedLengthX,0], [0,bedWidthY], [bedLengthX,bedWidthY]];
        const maxToolZ = panelZHeight + LIFT_HEIGHT + 500;
        const zLevels = [-BED_THICKNESS, 0, maxToolZ];
        
        const projCorners = [];
        for (const [bx, by] of bedCorners) {
            const rx = bx * cosVA - by * sinVA;
            const ry = bx * sinVA + by * cosVA;
            for (const z of zLevels) {
                projCorners.push({
                    x: (-rx * ISO_COS + ry * ISO_COS),
                    y: (-rx * ISO_SIN - ry * ISO_SIN - z)
                });
            }
        }
        
        const minPX = Math.min(...projCorners.map(c => c.x));
        const maxPX = Math.max(...projCorners.map(c => c.x));
        const minPY = Math.min(...projCorners.map(c => c.y));
        const maxPY = Math.max(...projCorners.map(c => c.y));
        
        const projWidth = maxPX - minPX;
        const projHeight = maxPY - minPY;
        
        const scaleX = plotWidth / projWidth;
        const scaleY = plotHeight / projHeight;
        const scale = Math.min(scaleX, scaleY) * 0.85;
        
        // Center the projection in the SVG
        const centerX = svgWidth / 2 - ((minPX + maxPX) / 2) * scale;
        const centerY = svgHeight / 2 - ((minPY + maxPY) / 2) * scale;
        
        // Core isometric projection: world (wx, wy, wz) → SVG (x, y)
        // Rotates world XY by viewAngle before projecting
        function worldToSvg3D(wx, wy, wz) {
            const rx = wx * cosVA - wy * sinVA;
            const ry = wx * sinVA + wy * cosVA;
            return {
                x: (-rx * ISO_COS + ry * ISO_COS) * scale + centerX,
                y: (-rx * ISO_SIN - ry * ISO_SIN - wz) * scale + centerY
            };
        }
        
        // 2D convenience (z=0) - compatible with existing demo code
        function worldToSvg(wx, wy) {
            return worldToSvg3D(wx, wy, 0);
        }
        
        // Helper: set polygon points from array of {x,y}
        function setPolygon(el, pts) {
            if (!el) return;
            el.setAttribute('points', pts.map(p => `${p.x},${p.y}`).join(' '));
        }
        
        // --- Face visibility based on viewAngle ---
        // View direction in rotated frame is (1,1). A face with world-normal (nx,ny)
        // is visible when dot(rotatedNormal, viewDir) < 0.
        const showFront = (sinVA - cosVA) < 0;   // Y=min face
        const showBack  = (cosVA - sinVA) < 0;   // Y=max face
        const showRight = (cosVA + sinVA) > 0;    // X=min face
        const showLeft  = (cosVA + sinVA) < 0;    // X=max face
        
        // Helper: draw a box (bed or panel) with correct face visibility and depth order
        function drawBox(groupEl, prefix, x0, y0, x1, y1, zTop, zBot) {
            const faces = [
                { id: `${prefix}-side-front`, pts: () => [
                    worldToSvg3D(x0, y0, zTop), worldToSvg3D(x1, y0, zTop),
                    worldToSvg3D(x1, y0, zBot), worldToSvg3D(x0, y0, zBot)
                ], visible: showFront, depth: 0 * cosVA + (-y0) * sinVA + (-y0) * cosVA },
                { id: `${prefix}-side-back`, pts: () => [
                    worldToSvg3D(x1, y1, zTop), worldToSvg3D(x0, y1, zTop),
                    worldToSvg3D(x0, y1, zBot), worldToSvg3D(x1, y1, zBot)
                ], visible: showBack, depth: 0 },
                { id: `${prefix}-side-right`, pts: () => [
                    worldToSvg3D(x0, y1, zTop), worldToSvg3D(x0, y0, zTop),
                    worldToSvg3D(x0, y0, zBot), worldToSvg3D(x0, y1, zBot)
                ], visible: showRight, depth: 0 },
                { id: `${prefix}-side-left`, pts: () => [
                    worldToSvg3D(x1, y0, zTop), worldToSvg3D(x1, y1, zTop),
                    worldToSvg3D(x1, y1, zBot), worldToSvg3D(x1, y0, zBot)
                ], visible: showLeft, depth: 0 },
                { id: `${prefix}-top`, pts: () => [
                    worldToSvg3D(x0, y0, zTop), worldToSvg3D(x1, y0, zTop),
                    worldToSvg3D(x1, y1, zTop), worldToSvg3D(x0, y1, zTop)
                ], visible: true, depth: -Infinity }, // always last (on top)
            ];
            
            // Compute depth for sorting: center of each face projected onto view direction
            for (const f of faces) {
                if (f.id.includes('-top')) continue;
                // Face center in rotated frame → depth = rx + ry
                let cx, cy;
                if (f.id.includes('-front')) { cx = (x0+x1)/2; cy = y0; }
                else if (f.id.includes('-back')) { cx = (x0+x1)/2; cy = y1; }
                else if (f.id.includes('-right')) { cx = x0; cy = (y0+y1)/2; }
                else { cx = x1; cy = (y0+y1)/2; }
                const rx = cx * cosVA - cy * sinVA;
                const ry = cx * sinVA + cy * cosVA;
                f.depth = rx + ry; // higher = further from viewer = draw first
            }
            
            // Sort: higher depth first (drawn first = behind), top always last
            faces.sort((a, b) => {
                if (a.id.includes('-top')) return 1;
                if (b.id.includes('-top')) return -1;
                return b.depth - a.depth;
            });
            
            // Reorder elements and set visibility
            for (const f of faces) {
                const el = document.getElementById(f.id);
                if (!el) continue;
                if (f.visible) {
                    setPolygon(el, f.pts());
                    el.style.display = '';
                } else {
                    el.style.display = 'none';
                }
                groupEl.appendChild(el); // moves to end = drawn on top
            }
        }
        
        // --- Draw bed as 3D slab ---
        const bedZ = 0;
        const bedZBottom = -BED_THICKNESS;
        const bedGroup = document.getElementById('bed-group');
        drawBox(bedGroup, 'bed', 0, 0, bedLengthX, bedWidthY, bedZ, bedZBottom);
        
        // --- Draw panel as 3D slab on top of bed ---
        const panelZ = panelZHeight;
        const panelZBottom = 0;
        const px0 = panelDatumX;
        const py0 = panelDatumY;
        const px1 = panelDatumX + panelX;
        const py1 = panelDatumY + panelY;
        const panelGroup = document.getElementById('panel-group');
        drawBox(panelGroup, 'panel', px0, py0, px1, py1, panelZ, panelZBottom);
        
        // --- Axis labels ---
        axisLabels.innerHTML = '';
        dimensionLabels.innerHTML = '';
        
        const originSvg = worldToSvg(0, 0);
        
        // X axis line (goes upper-left)
        const xEnd = worldToSvg(bedLengthX * 0.15, 0);
        const xLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        xLine.setAttribute('x1', originSvg.x); xLine.setAttribute('y1', originSvg.y);
        xLine.setAttribute('x2', xEnd.x); xLine.setAttribute('y2', xEnd.y);
        xLine.setAttribute('stroke', '#ef4444'); xLine.setAttribute('stroke-width', '1.5');
        xLine.setAttribute('marker-end', 'none');
        axisLabels.appendChild(xLine);
        const xLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        xLabel.setAttribute('x', xEnd.x - 5); xLabel.setAttribute('y', xEnd.y - 5);
        xLabel.setAttribute('fill', '#ef4444'); xLabel.setAttribute('font-size', '10'); xLabel.setAttribute('font-weight', 'bold');
        xLabel.textContent = 'X';
        axisLabels.appendChild(xLabel);
        
        // Y axis line (goes upper-right)
        const yEnd = worldToSvg(0, bedWidthY * 0.3);
        const yLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        yLine.setAttribute('x1', originSvg.x); yLine.setAttribute('y1', originSvg.y);
        yLine.setAttribute('x2', yEnd.x); yLine.setAttribute('y2', yEnd.y);
        yLine.setAttribute('stroke', '#22c55e'); yLine.setAttribute('stroke-width', '1.5');
        axisLabels.appendChild(yLine);
        const yLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        yLabel.setAttribute('x', yEnd.x + 5); yLabel.setAttribute('y', yEnd.y - 5);
        yLabel.setAttribute('fill', '#22c55e'); yLabel.setAttribute('font-size', '10'); yLabel.setAttribute('font-weight', 'bold');
        yLabel.textContent = 'Y';
        axisLabels.appendChild(yLabel);
        
        // Origin marker
        const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
        circle.setAttribute('cx', originSvg.x); circle.setAttribute('cy', originSvg.y);
        circle.setAttribute('r', '3'); circle.setAttribute('fill', '#ef4444');
        axisLabels.appendChild(circle);
        
        // Origin label
        const oLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        oLabel.setAttribute('x', originSvg.x + 6); oLabel.setAttribute('y', originSvg.y + 12);
        oLabel.setAttribute('fill', '#9ca3af'); oLabel.setAttribute('font-size', '9');
        oLabel.textContent = '(0,0)';
        axisLabels.appendChild(oLabel);
        
        // Panel dimension label (centered on panel top face)
        const panelCenter = worldToSvg3D((px0 + px1) / 2, (py0 + py1) / 2, panelZ);
        const panelLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        panelLabel.setAttribute('x', panelCenter.x); panelLabel.setAttribute('y', panelCenter.y);
        panelLabel.setAttribute('fill', '#6b7280'); panelLabel.setAttribute('font-size', '9');
        panelLabel.setAttribute('text-anchor', 'middle');
        panelLabel.textContent = `${panelX} × ${panelY}`;
        dimensionLabels.appendChild(panelLabel);
        
        // Hard Y Offset line (isometric)
        const hardYOffset = getVal('hard_y_offset', 0);
        if (hardYOffset > 0) {
            const hy0 = worldToSvg(0, hardYOffset);
            const hy1 = worldToSvg(bedLengthX, hardYOffset);
            
            const hardYLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            hardYLine.setAttribute('x1', hy0.x); hardYLine.setAttribute('y1', hy0.y);
            hardYLine.setAttribute('x2', hy1.x); hardYLine.setAttribute('y2', hy1.y);
            hardYLine.setAttribute('stroke', '#f97316');
            hardYLine.setAttribute('stroke-width', '2');
            hardYLine.setAttribute('stroke-dasharray', '8,4');
            dimensionLabels.appendChild(hardYLine);
            
            const hardYLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            hardYLabel.setAttribute('x', hy0.x + 5); hardYLabel.setAttribute('y', hy0.y - 4);
            hardYLabel.setAttribute('fill', '#f97316'); hardYLabel.setAttribute('font-size', '9');
            hardYLabel.textContent = `Hard Y (${hardYOffset})`;
            dimensionLabels.appendChild(hardYLabel);
        }
        
        // Expose for pattern overlay and demos
        window.bedVisualization = { update: updateVisualization, worldToSvg, worldToSvg3D, scale, centerX, centerY, ISO_COS, ISO_SIN, panelZ, LIFT_HEIGHT, viewAngle };
        
        // Validation: highlight inputs if panel exceeds bed
        const panelExceedsX = (panelDatumX + panelX) > bedLengthX;
        const panelExceedsY = (panelDatumY + panelY) > bedWidthY;
        
        const panelXInput = document.querySelector('input[name="panel_x"]');
        const panelYInput = document.querySelector('input[name="panel_y"]');
        const panelDatumXInput = document.querySelector('input[name="panel_datum_x"]');
        const panelDatumYInput = document.querySelector('input[name="panel_datum_y"]');
        
        const errorStyle = 'border-color: #ef4444; box-shadow: 0 0 0 1px #ef4444;';
        const normalStyle = '';
        
        if (panelExceedsX) {
            if (panelXInput) panelXInput.style.cssText = errorStyle;
            if (panelDatumXInput) panelDatumXInput.style.cssText = errorStyle;
        } else {
            if (panelXInput) panelXInput.style.cssText = normalStyle;
            if (panelDatumXInput) panelDatumXInput.style.cssText = normalStyle;
        }
        
        if (panelExceedsY) {
            if (panelYInput) panelYInput.style.cssText = errorStyle;
            if (panelDatumYInput) panelDatumYInput.style.cssText = errorStyle;
        } else {
            if (panelYInput) panelYInput.style.cssText = normalStyle;
            if (panelDatumYInput) panelDatumYInput.style.cssText = normalStyle;
        }
        
        // Show warning message if panel exceeds bed
        let warningEl = document.getElementById('panel-warning');
        if (!warningEl) {
            warningEl = document.createElement('div');
            warningEl.id = 'panel-warning';
            warningEl.className = 'text-[10px] text-red-400 mt-1';
            document.getElementById('bed-visualization').appendChild(warningEl);
        }
        
        if (panelExceedsX || panelExceedsY) {
            const xMsg = panelExceedsX ? `X: ${panelDatumX + panelX} > ${bedLengthX}` : '';
            const yMsg = panelExceedsY ? `Y: ${panelDatumY + panelY} > ${bedWidthY}` : '';
            warningEl.textContent = `Panel exceeds bed: ${[xMsg, yMsg].filter(Boolean).join(', ')}`;
            warningEl.classList.remove('hidden');
        } else {
            warningEl.classList.add('hidden');
        }
    }
    
    updateVisualization();
    
    ['bed_length_x', 'bed_width_y', 'panel_x', 'panel_y', 'panel_datum_x', 'panel_datum_y', 'hard_y_offset', 'panel_z'].forEach(name => {
        const input = document.querySelector(`input[name="${name}"]`);
        if (input) input.addEventListener('input', updateVisualization);
    });
    
    // --- View rotation: mouse drag to orbit around Z axis ---
    svg.style.cursor = 'grab';
    let isDragging = false;
    let lastMouseX = 0;
    
    function onViewChange() {
        updateVisualization();
        // Re-render path and coverage if a demo is active
        if (demoState && demoState.active && demoState.points) {
            drawPatternPath(demoState.points, demoState.tool);
            renderCoverage();
        }
    }
    
    svg.addEventListener('mousedown', (e) => {
        if (e.button !== 0) return; // left button only
        isDragging = true;
        lastMouseX = e.clientX;
        svg.style.cursor = 'grabbing';
        e.preventDefault();
    });
    
    document.addEventListener('mousemove', (e) => {
        if (!isDragging) return;
        const dx = e.clientX - lastMouseX;
        lastMouseX = e.clientX;
        viewAngle += dx * 0.5; // 0.5 degrees per pixel
        onViewChange();
    });
    
    document.addEventListener('mouseup', () => {
        if (!isDragging) return;
        isDragging = false;
        svg.style.cursor = 'grab';
    });
    
    // Touch support for mobile
    svg.addEventListener('touchstart', (e) => {
        if (e.touches.length === 1) {
            isDragging = true;
            lastMouseX = e.touches[0].clientX;
            e.preventDefault();
        }
    }, { passive: false });
    
    document.addEventListener('touchmove', (e) => {
        if (!isDragging || e.touches.length !== 1) return;
        const dx = e.touches[0].clientX - lastMouseX;
        lastMouseX = e.touches[0].clientX;
        viewAngle += dx * 0.5;
        onViewChange();
    });
    
    document.addEventListener('touchend', () => {
        isDragging = false;
    });
}

// =============================================================================
// Demo Animation System
// =============================================================================

const TOOL_COLORS = {
    vacuum: '#60a5fa',      // blue-400
    polisher: '#4ade80',    // green-400
    helicopter: '#c084fc',  // purple-400
    pan: '#fb923c',         // orange-400
    screed: '#facc15',      // yellow-400
    trowel: '#fb7185',      // rose-400
};

// Tool diameters - read from form inputs (fall back to defaults)
function getToolDiameter(tool) {
    const getVal = (name, def) => {
        const el = document.querySelector(`input[name="${name}"]`);
        const v = el ? parseFloat(el.value) : NaN;
        return isNaN(v) ? def : v;
    };
    switch(tool) {
        case 'vacuum': return getVal('vacuum_diameter', 500);
        case 'polisher': return getVal('polisher_diameter', 450);
        case 'helicopter': return getVal('heli_diameter', 1150);
        case 'pan': return getVal('pan_diameter', 600);
        case 'trowel': return getVal('trowel_diameter', 450);
        default: return 500;
    }
}
const SCREED_LENGTH_Y = 3800; // mm (along Y axis)
const SCREED_WIDTH_X = 120;   // mm (along X axis)
const VACUUM_LENGTH_Y = 300;  // mm (along Y axis - legacy, now uses diameter)
const VACUUM_WIDTH_X = 50;    // mm (along X axis - legacy)
const VACUUM_HANDLE_LENGTH = 250; // mm (matches 250mm offset about axis 6)
const VACUUM_HANDLE_WIDTH = 30;  // mm (wider for visibility)
const VACUUM_ROTATION_SPEED = 360; // degrees per second (0.5s for 180°)
const HELI_BLADE_RPM = 70;    // Default blade rotation speed
const ANIMATION_SPEED = 1000; // mm/s - speed for visual demo playback
// Tool speeds will be read from form inputs for duration calculation

let demoState = {
    active: false,
    tool: null,
    points: [],
    segments: [],      // { startIdx, endIdx, distance, startTime, endTime }
    totalDuration: 0,
    currentTime: 0,
    playing: false,
    animationFrame: null,
    lastCoverageTime: 0,
    coverageGrid: null,  // 2D grid for tracking coverage intensity
    gridCellSize: 50,    // mm per cell for coverage tracking
};

function setupDemoButtons() {
    document.querySelectorAll('.demo-btn').forEach(btn => {
        btn.addEventListener('click', async () => {
            const tool = btn.dataset.tool;
            await startDemo(tool);
        });
    });
    
    // Timeline controls
    const playBtn = document.getElementById('demo-play-btn');
    const slider = document.getElementById('demo-slider');
    
    if (playBtn) {
        playBtn.addEventListener('click', togglePlayPause);
    }
    
    if (slider) {
        slider.addEventListener('input', (e) => {
            if (demoState.active) {
                pauseDemo();
                const t = (parseFloat(e.target.value) / 1000) * demoState.totalDuration;
                demoState.currentTime = t;
                updateToolPosition(t);
                updateTimeDisplay(t);
                updateCoverageToTime(t);
            }
        });
    }
}

async function startDemo(tool) {
    // Stop any existing demo
    stopDemo();
    
    // Get current form parameters
    const getVal = (name, def) => {
        const el = document.querySelector(`input[name="${name}"]`);
        const v = el ? parseFloat(el.value) : NaN;
        return isNaN(v) ? def : v;
    };
    const getSelect = (name, def) => {
        const el = document.querySelector(`select[name="${name}"]`);
        return el ? el.value : def;
    };
    
    const params = {
        tool,
        panel_datum_x: getVal('panel_datum_x', 0),
        panel_datum_y: getVal('panel_datum_y', 0),
        panel_x: getVal('panel_x', 3000),
        panel_y: getVal('panel_y', 2000),
        bed_length_x: getVal('bed_length_x', 12000),
        bed_width_y: getVal('bed_width_y', 3300),
        polisher_workzone: getSelect('polisher_workzone', 'panel'),
        polisher_step: getVal('polisher_step', 200),
        polisher_pattern: getSelect('polisher_pattern', 'cross-hatch'),
        heli_workzone: getSelect('heli_workzone', 'panel'),
        helicopter_step: getVal('helicopter_step', 150),
        heli_pattern: getSelect('heli_pattern', 'cross-hatch'),
        heli_formwork_offset: getVal('heli_formwork_offset', 50),
        heli_spiral_direction: getSelect('heli_spiral_direction', 'anticlockwise'),
        heli_blade_speed: parseInt(getSelect('heli_blade_speed', '70')),
        heli_blade_direction: getSelect('heli_blade_direction', 'FWD'),
        pan_step: getVal('pan_step', 200),
        pan_travel_speed: parseInt(getSelect('pan_travel_speed', '100')),
        vacuum_workzone: getSelect('vacuum_workzone', 'panel'),
        vacuum_step: getVal('vacuum_step', 400),
        vacuum_pattern: getSelect('vacuum_pattern', 'cross-hatch'),
        vacuum_speed: getVal('vacuum_speed', 100),
        polisher_speed: getVal('polisher_speed', 100),
        heli_travel_speed: parseInt(getSelect('heli_travel_speed', '40')),
        vib_screed_speed: getVal('vib_screed_speed', 100),
        hard_y_offset: getVal('hard_y_offset', 0),
        screed_edge_offset: getVal('screed_edge_offset', 200),
        trowel_speed: getVal('trowel_speed', 100),
        trowel_step: getVal('trowel_step', 300),
        trowel_pass_1_angle: getVal('trowel_pass_1_angle', 0),
        trowel_pass_1_rotation: getVal('trowel_pass_1_rotation', 45),
        trowel_pass_2_angle: getVal('trowel_pass_2_angle', 0),
        trowel_pass_2_rotation: getVal('trowel_pass_2_rotation', 45),
    };
    
    try {
        const response = await fetch('/api/toolpath/pattern-points/', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(params),
        });
        const data = await response.json();
        
        if (!data.success || !data.points || data.points.length < 2) {
            console.error('Failed to get pattern points:', data.error);
            return;
        }
        
        // Get tool speed for actual duration calculation
        const toolSpeeds = {
            'vacuum': params.vacuum_speed || 100,
            'polisher': params.polisher_speed || 100,
            'helicopter': params.heli_travel_speed || 40,
            'pan': params.pan_travel_speed || 100,
            'screed': params.vib_screed_speed || 100,
            'trowel': params.trowel_speed || 100,
        };
        const toolSpeed = toolSpeeds[tool] || 100;
        
        // Calculate segments and timing (including rotation time for vacuum)
        const points = data.points;
        const segments = [];
        let animationTime = 0;  // Time for animation (at ANIMATION_SPEED)
        let actualTime = 0;     // Time for actual duration estimate (at tool speed)
        
        // Pre-compute Z height for each point based on move_type context:
        // "lift" = at lifted height, "rapid" after "lift" = still lifted, otherwise on surface
        const { panelZ: _pz, LIFT_HEIGHT: _lh } = window.bedVisualization || {};
        const surfaceZ = _pz || 0;
        const liftedZ = surfaceZ + (_lh || 250);
        for (let i = 0; i < points.length; i++) {
            const mt = points[i].move_type;
            if (mt === 'lift') {
                points[i]._z = liftedZ;
            } else if (mt === 'rapid' && i > 0 && (points[i - 1].move_type === 'lift' || points[i - 1].move_type === 'rapid')) {
                points[i]._z = liftedZ; // rapid transit after lift stays at height
            } else {
                points[i]._z = surfaceZ; // "work" or initial "rapid" = on surface
            }
        }
        
        const Z_TRANSITION_TIME = 0.3; // seconds for lift/descend animation
        
        for (let i = 0; i < points.length - 1; i++) {
            const p1 = points[i];
            const p2 = points[i + 1];
            const dx = p2.x - p1.x;
            const dy = p2.y - p1.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            
            // Check if axis_6 changes (rotation needed) - for vacuum and trowel tools
            const axis6Changed = ((tool === 'vacuum' || tool === 'trowel') && 
                p1.axis_6 !== null && p2.axis_6 !== null && 
                p1.axis_6 !== p2.axis_6);
            
            // If rotation occurs, add rotation segment first (stationary, rotating)
            if (axis6Changed) {
                const rotationDelta = Math.abs(p2.axis_6 - p1.axis_6);
                const rotationTime = rotationDelta / VACUUM_ROTATION_SPEED;
                
                segments.push({
                    startIdx: i,
                    endIdx: i,
                    distance: 0,
                    startTime: animationTime,
                    endTime: animationTime + rotationTime,
                    isRotation: true,
                    rotateFrom: p1.axis_6,
                    rotateTo: p2.axis_6,
                });
                animationTime += rotationTime;
                actualTime += rotationTime;
            }
            
            // Calculate travel times
            let animTravelTime = dist / ANIMATION_SPEED;
            const actualTravelTime = dist / toolSpeed;
            
            // Give zero-distance Z-transitions a minimum duration for smooth animation
            const zChanged = (p1._z !== undefined && p2._z !== undefined && p1._z !== p2._z);
            if (dist === 0 && zChanged) {
                animTravelTime = Z_TRANSITION_TIME;
            }
            
            segments.push({
                startIdx: i,
                endIdx: i + 1,
                distance: dist,
                startTime: animationTime,
                endTime: animationTime + animTravelTime,
                isRotation: false,
            });
            animationTime += animTravelTime;
            actualTime += actualTravelTime;
        }
        
        const totalDuration = animationTime;  // Animation duration
        const actualDuration = actualTime;    // Actual duration at tool speed
        
        demoState = {
            active: true,
            tool,
            points,
            segments,
            totalDuration,
            currentTime: 0,
            playing: false,
            animationFrame: null,
            lastCoverageTime: -1,
            coverageGrid: null,
            gridCellSize: 50,
            bladeDirection: params.heli_blade_direction || 'FWD',  // For helicopter blade rotation
            bladeRPM: params.heli_blade_speed || HELI_BLADE_RPM,
            bladeAngle: 0,  // Current blade rotation angle
        };
        
        // Initialize coverage grid
        initCoverageGrid(params.bed_length_x, params.bed_width_y);
        
        // Draw path
        drawPatternPath(points, tool);
        
        // Create tool circle
        createToolCircle(tool);
        
        // Show timeline
        const timeline = document.getElementById('demo-timeline');
        if (timeline) timeline.classList.remove('hidden');
        
        // Update labels
        const toolNameEl = document.getElementById('demo-tool-name');
        if (toolNameEl) toolNameEl.textContent = tool.charAt(0).toUpperCase() + tool.slice(1);
        
        const durationEl = document.getElementById('demo-duration');
        if (durationEl) {
            // Show actual duration (at tool speed), not animation duration
            const mins = Math.floor(actualDuration / 60);
            const secs = actualDuration % 60;
            if (mins > 0) {
                durationEl.textContent = `${mins}m ${secs.toFixed(0)}s`;
            } else {
                durationEl.textContent = actualDuration.toFixed(1) + 's';
            }
        }
        
        // Reset slider
        const slider = document.getElementById('demo-slider');
        if (slider) slider.value = 0;
        
        updateTimeDisplay(0);
        updateToolPosition(0);
        
        // Auto-play
        playDemo();
        
    } catch (err) {
        console.error('Demo error:', err);
    }
}

function drawPatternPath(points, tool) {
    const pathGroup = document.getElementById('pattern-path');
    if (!pathGroup || !window.bedVisualization) return;
    
    pathGroup.innerHTML = '';
    const { worldToSvg, worldToSvg3D, panelZ, LIFT_HEIGHT } = window.bedVisualization;
    const color = TOOL_COLORS[tool] || '#fff';
    
    // Helper: get Z height for a point based on move_type
    function pointZ(p) {
        if (p.move_type === 'lift' || p.move_type === 'rapid') {
            return (panelZ || 0) + (LIFT_HEIGHT || 100);
        }
        return panelZ || 0; // "work" = on panel surface
    }
    
    // Draw path lines at correct Z heights
    for (let i = 0; i < points.length - 1; i++) {
        const pa = points[i];
        const pb = points[i + 1];
        const z1 = pointZ(pa);
        const z2 = pointZ(pb);
        const p1 = worldToSvg3D ? worldToSvg3D(pa.x, pa.y, z1) : worldToSvg(pa.x, pa.y);
        const p2 = worldToSvg3D ? worldToSvg3D(pb.x, pb.y, z2) : worldToSvg(pb.x, pb.y);
        
        const isLifted = (pa.move_type === 'lift' || pa.move_type === 'rapid' ||
                          pb.move_type === 'lift' || pb.move_type === 'rapid');
        
        const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        line.setAttribute('x1', p1.x);
        line.setAttribute('y1', p1.y);
        line.setAttribute('x2', p2.x);
        line.setAttribute('y2', p2.y);
        line.setAttribute('stroke', color);
        line.setAttribute('stroke-width', isLifted ? '0.5' : '1');
        line.setAttribute('stroke-opacity', isLifted ? '0.25' : '0.4');
        if (isLifted) {
            line.setAttribute('stroke-dasharray', '4,3');
        }
        pathGroup.appendChild(line);
    }
}

function createToolCircle(tool) {
    const circleGroup = document.getElementById('tool-circle');
    if (!circleGroup || !window.bedVisualization) return;
    
    circleGroup.innerHTML = '';
    const { scale } = window.bedVisualization;
    const color = TOOL_COLORS[tool] || '#fff';
    
    if (tool === 'screed') {
        // Screed is a rectangle: 3800mm (Y) x 120mm (X)
        const width = SCREED_WIDTH_X * scale;
        const height = SCREED_LENGTH_Y * scale;
        
        const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
        rect.setAttribute('id', 'demo-tool');
        rect.setAttribute('width', width);
        rect.setAttribute('height', height);
        rect.setAttribute('fill', color);
        rect.setAttribute('fill-opacity', '0.6');
        rect.setAttribute('stroke', color);
        rect.setAttribute('stroke-width', '2');
        circleGroup.appendChild(rect);
    } else if (tool === 'vacuum') {
        // Vacuum is a rectangle with handle - create a group
        const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
        g.setAttribute('id', 'demo-tool');
        
        const bodyWidth = VACUUM_WIDTH_X * scale;
        const bodyHeight = VACUUM_LENGTH_Y * scale;
        const handleWidth = VACUUM_HANDLE_WIDTH * scale;
        const handleHeight = VACUUM_HANDLE_LENGTH * scale;
        
        // Main body
        const body = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
        body.setAttribute('id', 'vacuum-body');
        body.setAttribute('width', bodyWidth);
        body.setAttribute('height', bodyHeight);
        body.setAttribute('x', -bodyWidth / 2);
        body.setAttribute('y', -bodyHeight / 2);
        body.setAttribute('fill', color);
        body.setAttribute('fill-opacity', '0.6');
        body.setAttribute('stroke', color);
        body.setAttribute('stroke-width', '2');
        g.appendChild(body);
        
        // Handle (on leading edge - positioned for axis_6=0 state, rotation handled by transform)
        // At axis_6=0: tool faces left (negative X), handle is on right side (trailing edge)
        // When axis_6=180: group rotates, handle appears on left side
        // Handle is perpendicular to body: handleHeight along X, handleWidth along Y
        const handle = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
        handle.setAttribute('id', 'vacuum-handle');
        handle.setAttribute('width', handleHeight);  // Length along X
        handle.setAttribute('height', handleWidth);  // Width along Y
        handle.setAttribute('x', bodyWidth / 2);  // Right side at axis_6=0
        handle.setAttribute('y', -handleWidth / 2);
        handle.setAttribute('fill', color);
        handle.setAttribute('fill-opacity', '0.8');
        handle.setAttribute('stroke', color);
        handle.setAttribute('stroke-width', '1');
        g.appendChild(handle);
        
        circleGroup.appendChild(g);
    } else if (tool === 'helicopter' || tool === 'pan') {
        // Helicopter/Pan with rotating blades
        const diameter = getToolDiameter(tool);
        const radius = (diameter / 2) * scale;
        
        const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
        g.setAttribute('id', 'demo-tool');
        
        // Center hub
        const hub = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
        hub.setAttribute('r', radius * 0.15);
        hub.setAttribute('fill', color);
        hub.setAttribute('fill-opacity', '0.8');
        hub.setAttribute('stroke', color);
        hub.setAttribute('stroke-width', '2');
        g.appendChild(hub);
        
        // Blades group (will rotate)
        const bladesGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
        bladesGroup.setAttribute('id', 'heli-blades');
        
        // 4 blades
        const bladeWidth = radius * 0.12;
        for (let i = 0; i < 4; i++) {
            const blade = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
            blade.setAttribute('x', -bladeWidth / 2);
            blade.setAttribute('y', -radius);
            blade.setAttribute('width', bladeWidth);
            blade.setAttribute('height', radius);
            blade.setAttribute('fill', color);
            blade.setAttribute('fill-opacity', '0.6');
            blade.setAttribute('stroke', color);
            blade.setAttribute('stroke-width', '1');
            blade.setAttribute('transform', `rotate(${i * 90})`);
            bladesGroup.appendChild(blade);
        }
        
        g.appendChild(bladesGroup);
        circleGroup.appendChild(g);
    } else if (tool === 'trowel') {
        // 3D Trowel: 150×450×3mm plate + 63mm dia × 500mm shaft
        const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
        g.setAttribute('id', 'demo-tool');
        
        // Plate front side face (3mm thick visible edge) - drawn first (behind everything)
        const plateSide = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
        plateSide.setAttribute('id', 'trowel-plate-side');
        plateSide.setAttribute('fill', '#e11d48');
        plateSide.setAttribute('fill-opacity', '0.7');
        plateSide.setAttribute('stroke', color);
        plateSide.setAttribute('stroke-width', '0.5');
        g.appendChild(plateSide);
        
        // Plate top face (colored parallelogram)
        const plateTop = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
        plateTop.setAttribute('id', 'trowel-plate-top');
        plateTop.setAttribute('fill', color);
        plateTop.setAttribute('fill-opacity', '0.8');
        plateTop.setAttribute('stroke', color);
        plateTop.setAttribute('stroke-width', '1.5');
        g.appendChild(plateTop);
        
        // Shaft body (vertical silhouette polygon) - drawn after plate so it appears in front
        const shaftBody = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
        shaftBody.setAttribute('id', 'trowel-shaft');
        shaftBody.setAttribute('fill', '#9ca3af');
        shaftBody.setAttribute('fill-opacity', '0.9');
        shaftBody.setAttribute('stroke', '#6b7280');
        shaftBody.setAttribute('stroke-width', '1');
        g.appendChild(shaftBody);
        
        // Shaft top ellipse cap - drawn last (on top of everything)
        const shaftCap = document.createElementNS('http://www.w3.org/2000/svg', 'ellipse');
        shaftCap.setAttribute('id', 'trowel-shaft-cap');
        shaftCap.setAttribute('fill', '#d1d5db');
        shaftCap.setAttribute('stroke', '#6b7280');
        shaftCap.setAttribute('stroke-width', '1');
        g.appendChild(shaftCap);
        
        circleGroup.appendChild(g);
    } else {
        // Polisher is a circle
        const diameter = getToolDiameter(tool);
        const radius = (diameter / 2) * scale;
        
        const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
        circle.setAttribute('id', 'demo-tool');
        circle.setAttribute('r', radius);
        circle.setAttribute('cx', 0);  // Initial position, will be updated
        circle.setAttribute('cy', 0);
        circle.setAttribute('fill', color);
        circle.setAttribute('fill-opacity', '0.6');
        circle.setAttribute('stroke', color);
        circle.setAttribute('stroke-width', '2');
        circleGroup.appendChild(circle);
    }
}

function initCoverageGrid(bedLengthX, bedWidthY) {
    const cellSize = demoState.gridCellSize;
    const cols = Math.ceil(bedLengthX / cellSize);
    const rows = Math.ceil(bedWidthY / cellSize);
    
    demoState.coverageGrid = {
        cols,
        rows,
        cellSize,
        bedLengthX,
        bedWidthY,
        cells: new Array(cols * rows).fill(0),
    };
    
    // Clear existing coverage
    const coverageGroup = document.getElementById('coverage-trail');
    if (coverageGroup) coverageGroup.innerHTML = '';
}

function updateCoverage(toolX, toolY, axis6 = 0) {
    if (!demoState.coverageGrid || !window.bedVisualization) return;
    
    const { cols, rows, cellSize, cells } = demoState.coverageGrid;
    
    if (demoState.tool === 'screed') {
        // Screed is a rectangle: 3800mm (Y) x 120mm (X)
        const halfWidth = SCREED_WIDTH_X / 2;
        const halfHeight = SCREED_LENGTH_Y / 2;
        
        const minCol = Math.max(0, Math.floor((toolX - halfWidth) / cellSize));
        const maxCol = Math.min(cols - 1, Math.floor((toolX + halfWidth) / cellSize));
        const minRow = Math.max(0, Math.floor((toolY - halfHeight) / cellSize));
        const maxRow = Math.min(rows - 1, Math.floor((toolY + halfHeight) / cellSize));
        
        for (let col = minCol; col <= maxCol; col++) {
            for (let row = minRow; row <= maxRow; row++) {
                const idx = row * cols + col;
                cells[idx]++;
            }
        }
    } else if (demoState.tool === 'trowel') {
        // Trowel is a rectangle: 450mm (long edge) x 150mm (short edge), rotated by axis_6
        const angle = (axis6 || 0) * Math.PI / 180;
        const cos = Math.abs(Math.cos(angle));
        const sin = Math.abs(Math.sin(angle));
        const trowelL = 450;
        const trowelW = 150;
        
        // Rotated bounding box for broad-phase
        const halfWidth = (trowelL * cos + trowelW * sin) / 2;
        const halfHeight = (trowelL * sin + trowelW * cos) / 2;
        
        const minCol = Math.max(0, Math.floor((toolX - halfWidth) / cellSize));
        const maxCol = Math.min(cols - 1, Math.floor((toolX + halfWidth) / cellSize));
        const minRow = Math.max(0, Math.floor((toolY - halfHeight) / cellSize));
        const maxRow = Math.min(rows - 1, Math.floor((toolY + halfHeight) / cellSize));
        
        // Exact rotated rectangle test
        const cosExact = Math.cos(angle);
        const sinExact = Math.sin(angle);
        const rectHalfL = trowelL / 2;
        const rectHalfW = trowelW / 2;
        
        for (let col = minCol; col <= maxCol; col++) {
            for (let row = minRow; row <= maxRow; row++) {
                const cellCenterX = (col + 0.5) * cellSize;
                const cellCenterY = (row + 0.5) * cellSize;
                
                // Transform cell center to tool-local coordinates (rotate by -angle)
                const dx = cellCenterX - toolX;
                const dy = cellCenterY - toolY;
                const localX = dx * cosExact + dy * sinExact;
                const localY = -dx * sinExact + dy * cosExact;
                
                if (Math.abs(localX) <= rectHalfL && Math.abs(localY) <= rectHalfW) {
                    const idx = row * cols + col;
                    cells[idx]++;
                }
            }
        }
    } else if (demoState.tool === 'vacuum') {
        // Vacuum is a rectangle: 300mm (Y) x 50mm (X), rotates with axis_6
        // At axis_6=0: 50mm wide (X), 300mm tall (Y)
        // At axis_6=90 or -90: 300mm wide (X), 50mm tall (Y)
        const angle = (axis6 || 0) * Math.PI / 180;
        const cos = Math.abs(Math.cos(angle));
        const sin = Math.abs(Math.sin(angle));
        
        // Rotated bounding box dimensions
        const halfWidth = (VACUUM_WIDTH_X * cos + VACUUM_LENGTH_Y * sin) / 2;
        const halfHeight = (VACUUM_WIDTH_X * sin + VACUUM_LENGTH_Y * cos) / 2;
        
        const minCol = Math.max(0, Math.floor((toolX - halfWidth) / cellSize));
        const maxCol = Math.min(cols - 1, Math.floor((toolX + halfWidth) / cellSize));
        const minRow = Math.max(0, Math.floor((toolY - halfHeight) / cellSize));
        const maxRow = Math.min(rows - 1, Math.floor((toolY + halfHeight) / cellSize));
        
        // For more accurate coverage, check if cell center is inside rotated rectangle
        const cosExact = Math.cos(angle);
        const sinExact = Math.sin(angle);
        const rectHalfW = VACUUM_WIDTH_X / 2;
        const rectHalfH = VACUUM_LENGTH_Y / 2;
        
        for (let col = minCol; col <= maxCol; col++) {
            for (let row = minRow; row <= maxRow; row++) {
                const cellCenterX = (col + 0.5) * cellSize;
                const cellCenterY = (row + 0.5) * cellSize;
                
                // Transform cell center to tool-local coordinates (rotate by -angle)
                const dx = cellCenterX - toolX;
                const dy = cellCenterY - toolY;
                const localX = dx * cosExact + dy * sinExact;
                const localY = -dx * sinExact + dy * cosExact;
                
                // Check if inside rectangle
                if (Math.abs(localX) <= rectHalfW && Math.abs(localY) <= rectHalfH) {
                    const idx = row * cols + col;
                    cells[idx]++;
                }
            }
        }
    } else {
        // Circular tools - use actual diameter from form inputs
        const diameter = getToolDiameter(demoState.tool);
        const toolRadius = diameter / 2;
        
        const minCol = Math.max(0, Math.floor((toolX - toolRadius) / cellSize));
        const maxCol = Math.min(cols - 1, Math.floor((toolX + toolRadius) / cellSize));
        const minRow = Math.max(0, Math.floor((toolY - toolRadius) / cellSize));
        const maxRow = Math.min(rows - 1, Math.floor((toolY + toolRadius) / cellSize));
        
        for (let col = minCol; col <= maxCol; col++) {
            for (let row = minRow; row <= maxRow; row++) {
                const cellCenterX = (col + 0.5) * cellSize;
                const cellCenterY = (row + 0.5) * cellSize;
                const dx = cellCenterX - toolX;
                const dy = cellCenterY - toolY;
                const dist = Math.sqrt(dx * dx + dy * dy);
                
                if (dist <= toolRadius) {
                    const idx = row * cols + col;
                    cells[idx]++;
                }
            }
        }
    }
}

function renderCoverage() {
    if (!demoState.coverageGrid || !window.bedVisualization) return;
    
    const coverageGroup = document.getElementById('coverage-trail');
    if (!coverageGroup) return;
    
    coverageGroup.innerHTML = '';
    
    const { cols, rows, cellSize, cells } = demoState.coverageGrid;
    const { worldToSvg3D, panelZ } = window.bedVisualization;
    const color = TOOL_COLORS[demoState.tool] || '#fff';
    const z = panelZ || 0; // Draw coverage on top of panel surface
    
    // Find max coverage for normalization
    const maxCoverage = Math.max(...cells, 1);
    
    for (let row = 0; row < rows; row++) {
        for (let col = 0; col < cols; col++) {
            const idx = row * cols + col;
            const coverage = cells[idx];
            
            if (coverage > 0) {
                const normalizedCoverage = coverage / maxCoverage;
                const opacity = 0.15 + normalizedCoverage * 0.5;
                
                // Isometric parallelogram cell: project 4 corners at panel surface Z
                const wx0 = col * cellSize;
                const wy0 = row * cellSize;
                const wx1 = (col + 1) * cellSize;
                const wy1 = (row + 1) * cellSize;
                
                const p0 = worldToSvg3D(wx0, wy0, z);
                const p1 = worldToSvg3D(wx1, wy0, z);
                const p2 = worldToSvg3D(wx1, wy1, z);
                const p3 = worldToSvg3D(wx0, wy1, z);
                
                const poly = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
                poly.setAttribute('points',
                    `${p0.x},${p0.y} ${p1.x},${p1.y} ${p2.x},${p2.y} ${p3.x},${p3.y}`);
                poly.setAttribute('fill', color);
                poly.setAttribute('fill-opacity', opacity);
                coverageGroup.appendChild(poly);
            }
        }
    }
}

function updateCoverageToTime(targetTime) {
    // Reset and rebuild coverage up to targetTime
    if (!demoState.active) return;
    
    const { points, segments, gridCellSize } = demoState;
    
    // Reinitialize grid
    const grid = demoState.coverageGrid;
    if (grid) {
        grid.cells.fill(0);
    }
    
    // Sample positions along the path up to targetTime
    const sampleInterval = gridCellSize / 2; // Sample every half cell size in distance
    let currentAxis6 = points[0]?.axis_6 || 0;
    
    for (const seg of segments) {
        if (seg.startTime > targetTime) break;
        
        const p1 = points[seg.startIdx];
        const p2 = points[seg.endIdx];
        const segEndTime = Math.min(seg.endTime, targetTime);
        
        if (segEndTime <= seg.startTime) continue;
        
        const segDuration = seg.endTime - seg.startTime;
        const segProgress = segDuration > 0 ? (segEndTime - seg.startTime) / segDuration : 1;
        
        if (seg.isRotation) {
            // Rotation segment - update axis_6 but don't move
            currentAxis6 = seg.rotateFrom + (seg.rotateTo - seg.rotateFrom) * segProgress;
            // Still add coverage at current position
            updateCoverage(p1.x, p1.y, currentAxis6);
        } else {
            // Movement segment
            const segDistance = seg.distance * segProgress;
            
            // Get axis_6 for this segment (use target point's axis_6)
            const segAxis6 = p2.axis_6 !== null ? p2.axis_6 : currentAxis6;
            
            // Sample along this segment
            const numSamples = Math.max(1, Math.ceil(segDistance / sampleInterval));
            for (let i = 0; i <= numSamples; i++) {
                const t = i / numSamples * segProgress;
                const x = p1.x + (p2.x - p1.x) * t;
                const y = p1.y + (p2.y - p1.y) * t;
                updateCoverage(x, y, segAxis6);
            }
            
            currentAxis6 = segAxis6;
        }
    }
    
    renderCoverage();
}

function updateTrowel3D(wx, wy, axis6, wz, axis4) {
    // Compute 3D isometric positions for trowel plate + shaft
    // wz = Z height of the plate center (panel surface + any lift)
    // axis4 = plough angle: tilt about the tool's local Y axis (degrees)
    if (!window.bedVisualization) return;
    const { worldToSvg3D, scale, ISO_COS, ISO_SIN } = window.bedVisualization;
    
    const theta = axis6 * Math.PI / 180;
    const cos_t = Math.cos(theta);
    const sin_t = Math.sin(theta);
    
    // Axis 4 tilt about local Y axis (plough angle)
    const a4_rad = (axis4 || 0) * Math.PI / 180;
    const sin_a4 = Math.sin(a4_rad);
    const cos_a4 = Math.cos(a4_rad);
    
    // --- Plate: 450mm × 150mm × 3mm ---
    const halfL = 225;  // half of 450mm (long edge = local X)
    const halfW = 75;   // half of 150mm (short edge = local Y)
    
    // Each corner at local (dx, dy) gets Z offset from tilt about local Y:
    //   z_offset = dx * sin(axis4)  (positive axis4 raises the +X local end)
    // Rotate corner offsets by axis_6 to world coords
    function rot(dx, dy) {
        return { x: wx + dx * cos_t - dy * sin_t, y: wy + dx * sin_t + dy * cos_t };
    }
    function cornerZ(dx) {
        return dx * sin_a4;
    }
    
    const c0 = rot(-halfL, -halfW);  const cz0 = cornerZ(-halfL);
    const c1 = rot( halfL, -halfW);  const cz1 = cornerZ( halfL);
    const c2 = rot( halfL,  halfW);  const cz2 = cornerZ( halfL);
    const c3 = rot(-halfL,  halfW);  const cz3 = cornerZ(-halfL);
    
    const plateThick = 3;
    
    // Plate top face (each corner at its own Z)
    const pt0 = worldToSvg3D(c0.x, c0.y, wz + plateThick + cz0);
    const pt1 = worldToSvg3D(c1.x, c1.y, wz + plateThick + cz1);
    const pt2 = worldToSvg3D(c2.x, c2.y, wz + plateThick + cz2);
    const pt3 = worldToSvg3D(c3.x, c3.y, wz + plateThick + cz3);
    
    const plateTopEl = document.getElementById('trowel-plate-top');
    if (plateTopEl) {
        plateTopEl.setAttribute('points',
            `${pt0.x},${pt0.y} ${pt1.x},${pt1.y} ${pt2.x},${pt2.y} ${pt3.x},${pt3.y}`);
        // Visual indicator: plate darkens when tilted (ploughing)
        const tiltAmount = Math.abs(axis4 || 0) / 90;
        plateTopEl.setAttribute('fill-opacity', 0.8 - tiltAmount * 0.4);
    }
    
    // Plate front side face: find the two corners with highest SVG Y (closest to viewer)
    const cornersTop = [
        { c: c0, z: wz + plateThick + cz0, svgY: pt0.y },
        { c: c1, z: wz + plateThick + cz1, svgY: pt1.y },
        { c: c2, z: wz + plateThick + cz2, svgY: pt2.y },
        { c: c3, z: wz + plateThick + cz3, svgY: pt3.y },
    ];
    const czArr = [cz0, cz1, cz2, cz3];
    cornersTop.sort((a, b) => b.svgY - a.svgY);
    const frontA = cornersTop[0];
    const frontB = cornersTop[1];
    
    const sf0 = worldToSvg3D(frontA.c.x, frontA.c.y, frontA.z);
    const sf1 = worldToSvg3D(frontB.c.x, frontB.c.y, frontB.z);
    const sf2 = worldToSvg3D(frontB.c.x, frontB.c.y, frontB.z - plateThick);
    const sf3 = worldToSvg3D(frontA.c.x, frontA.c.y, frontA.z - plateThick);
    
    const plateSideEl = document.getElementById('trowel-plate-side');
    if (plateSideEl) {
        plateSideEl.setAttribute('points',
            `${sf0.x},${sf0.y} ${sf1.x},${sf1.y} ${sf2.x},${sf2.y} ${sf3.x},${sf3.y}`);
    }
    
    // --- Shaft: 63mm diameter × 500mm tall cylinder, tilted by axis_4 ---
    const shaftR = 31.5;
    const shaftH = 500;
    
    // Shaft base at plate center top (wz + plateThick, no tilt offset at center)
    const shaftBaseZ = wz + plateThick;
    // Shaft top: displaced along local X by shaftH * sin(a4), Z by shaftH * cos(a4)
    const shaftTopLocalDx = shaftH * sin_a4;
    const shaftTopDz = shaftH * cos_a4;
    // Rotate local X offset to world coords
    const shaftTopWx = wx + shaftTopLocalDx * cos_t;
    const shaftTopWy = wy + shaftTopLocalDx * sin_t;
    const shaftTopZ = shaftBaseZ + shaftTopDz;
    
    // Cylinder silhouette: perpendicular to isometric view direction
    const INV_SQRT2 = 0.7071;
    const perpX = shaftR * INV_SQRT2;
    const perpY = shaftR * INV_SQRT2;
    
    const sA_bot = worldToSvg3D(wx + perpX, wy - perpY, shaftBaseZ);
    const sA_top = worldToSvg3D(shaftTopWx + perpX, shaftTopWy - perpY, shaftTopZ);
    const sB_bot = worldToSvg3D(wx - perpX, wy + perpY, shaftBaseZ);
    const sB_top = worldToSvg3D(shaftTopWx - perpX, shaftTopWy + perpY, shaftTopZ);
    
    const shaftEl = document.getElementById('trowel-shaft');
    if (shaftEl) {
        shaftEl.setAttribute('points',
            `${sA_bot.x},${sA_bot.y} ${sA_top.x},${sA_top.y} ${sB_top.x},${sB_top.y} ${sB_bot.x},${sB_bot.y}`);
    }
    
    // Shaft top ellipse cap
    const capCenter = worldToSvg3D(shaftTopWx, shaftTopWy, shaftTopZ);
    const capRx = shaftR * Math.SQRT2 * ISO_COS * scale;
    const capRy = shaftR * Math.SQRT2 * ISO_SIN * scale;
    
    const capEl = document.getElementById('trowel-shaft-cap');
    if (capEl) {
        capEl.setAttribute('cx', capCenter.x);
        capEl.setAttribute('cy', capCenter.y);
        capEl.setAttribute('rx', capRx);
        capEl.setAttribute('ry', capRy);
    }
}

function updateToolPosition(time) {
    if (!demoState.active || !window.bedVisualization) return;
    
    const { points, segments, totalDuration } = demoState;
    const { worldToSvg } = window.bedVisualization;
    
    // Clamp time
    const t = Math.max(0, Math.min(time, totalDuration));
    
    // Find current segment and get position + axis_6
    let pos = { x: points[0].x, y: points[0].y };
    let currentAxis6 = points[0].axis_6 || 0;
    let currentAxis4 = points[0].axis_4 || 0;
    let currentMoveType = points[0].move_type || 'work';
    let isRotating = false;
    let rotationProgress = 0;
    let rotateFrom = 0;
    let rotateTo = 0;
    
    for (let i = 0; i < segments.length; i++) {
        const seg = segments[i];
        if (t >= seg.startTime && t <= seg.endTime) {
            const segDuration = seg.endTime - seg.startTime;
            const segProgress = segDuration > 0 ? (t - seg.startTime) / segDuration : 0;
            
            if (seg.isRotation) {
                // Rotation segment: tool stays in place, rotates
                pos = { x: points[seg.startIdx].x, y: points[seg.startIdx].y };
                currentMoveType = points[seg.startIdx].move_type || 'work';
                currentAxis4 = points[seg.startIdx].axis_4 || 0;
                isRotating = true;
                rotationProgress = segProgress;
                rotateFrom = seg.rotateFrom;
                rotateTo = seg.rotateTo;
                
                currentAxis6 = rotateFrom + (rotateTo - rotateFrom) * segProgress;
            } else {
                // Movement segment: interpolate axis_4 smoothly
                const p1 = points[seg.startIdx];
                const p2 = points[seg.endIdx];
                pos.x = p1.x + (p2.x - p1.x) * segProgress;
                pos.y = p1.y + (p2.y - p1.y) * segProgress;
                currentAxis6 = p2.axis_6 !== null ? p2.axis_6 : (p1.axis_6 || 0);
                const a4_1 = p1.axis_4 || 0;
                const a4_2 = p2.axis_4 || 0;
                currentAxis4 = a4_1 + (a4_2 - a4_1) * segProgress;
                currentMoveType = p2.move_type || 'work';
            }
            break;
        } else if (t > seg.endTime) {
            if (seg.isRotation) {
                pos = { x: points[seg.startIdx].x, y: points[seg.startIdx].y };
                currentAxis6 = seg.rotateTo;
                currentAxis4 = points[seg.startIdx].axis_4 || 0;
                currentMoveType = points[seg.startIdx].move_type || 'work';
            } else {
                pos = { x: points[seg.endIdx].x, y: points[seg.endIdx].y };
                currentAxis6 = points[seg.endIdx].axis_6 || 0;
                currentAxis4 = points[seg.endIdx].axis_4 || 0;
                currentMoveType = points[seg.endIdx].move_type || 'work';
            }
        }
    }
    
    const svgPos = worldToSvg(pos.x, pos.y);
    const toolEl = document.getElementById('demo-tool');
    if (toolEl) {
        if (demoState.tool === 'screed') {
            // Rectangle: position by top-left corner, centered on tool position
            const { scale } = window.bedVisualization;
            const width = SCREED_WIDTH_X * scale;
            const height = SCREED_LENGTH_Y * scale;
            toolEl.setAttribute('x', svgPos.x - width / 2);
            toolEl.setAttribute('y', svgPos.y - height / 2);
        } else if (demoState.tool === 'vacuum') {
            // Vacuum group: use transform to position and rotate based on axis_6
            // Rotation is animated during rotation segments
            const rotation = currentAxis6;
            toolEl.setAttribute('transform', `translate(${svgPos.x}, ${svgPos.y}) rotate(${rotation})`);
        } else if (demoState.tool === 'trowel') {
            // 3D Trowel: interpolate Z smoothly using pre-computed _z values
            const { panelZ } = window.bedVisualization;
            let toolZ = panelZ || 0;
            for (let si = 0; si < segments.length; si++) {
                const seg = segments[si];
                if (t >= seg.startTime && t <= seg.endTime) {
                    const segDuration = seg.endTime - seg.startTime;
                    const segProgress = segDuration > 0 ? (t - seg.startTime) / segDuration : 1;
                    if (seg.isRotation) {
                        toolZ = points[seg.startIdx]._z || toolZ;
                    } else {
                        const z1 = points[seg.startIdx]._z;
                        const z2 = points[seg.endIdx]._z;
                        if (z1 !== undefined && z2 !== undefined) {
                            toolZ = z1 + (z2 - z1) * segProgress;
                        }
                    }
                    break;
                } else if (t > seg.endTime) {
                    if (seg.isRotation) {
                        toolZ = points[seg.startIdx]._z || toolZ;
                    } else {
                        toolZ = points[seg.endIdx]._z || toolZ;
                    }
                }
            }
            updateTrowel3D(pos.x, pos.y, currentAxis6, toolZ, currentAxis4);
        } else if (demoState.tool === 'helicopter' || demoState.tool === 'pan') {
            // Helicopter/Pan group: position with transform (blade rotation handled separately)
            toolEl.setAttribute('transform', `translate(${svgPos.x}, ${svgPos.y})`);
        } else {
            // Circle (polisher): position by center
            toolEl.setAttribute('cx', svgPos.x);
            toolEl.setAttribute('cy', svgPos.y);
        }
    }
}

function updateTimeDisplay(time) {
    // Update slider position only (Time display removed)
    const slider = document.getElementById('demo-slider');
    if (slider && demoState.totalDuration > 0) {
        slider.value = (time / demoState.totalDuration) * 1000;
    }
}

function playDemo() {
    if (!demoState.active) return;
    
    demoState.playing = true;
    const playIcon = document.getElementById('play-icon');
    if (playIcon) playIcon.textContent = '⏸';
    
    let lastTime = performance.now();
    let lastCoverageUpdate = performance.now();
    
    function animate(now) {
        if (!demoState.playing) return;
        
        const delta = (now - lastTime) / 1000;
        lastTime = now;
        
        const prevTime = demoState.currentTime;
        demoState.currentTime += delta;
        
        if (demoState.currentTime >= demoState.totalDuration) {
            // Pause at end instead of looping
            demoState.currentTime = demoState.totalDuration;
            updateToolPosition(demoState.currentTime);
            updateTimeDisplay(demoState.currentTime);
            updateCoverageToTime(demoState.currentTime);
            pauseDemo();
            return;
        }
        
        updateToolPosition(demoState.currentTime);
        updateTimeDisplay(demoState.currentTime);
        
        // Update helicopter blade rotation
        if (demoState.tool === 'helicopter' || demoState.tool === 'pan') {
            updateBladeRotation(delta);
        }
        
        // Update coverage every 50ms for performance
        if (now - lastCoverageUpdate > 50) {
            updateCoverageToTime(demoState.currentTime);
            lastCoverageUpdate = now;
        }
        
        demoState.animationFrame = requestAnimationFrame(animate);
    }
    
    demoState.animationFrame = requestAnimationFrame(animate);
}

function updateBladeRotation(delta) {
    const blades = document.getElementById('heli-blades');
    if (!blades) return;
    
    // Calculate rotation speed: RPM to degrees per second
    // RPM * 360 / 60 = degrees per second
    const degreesPerSecond = demoState.bladeRPM * 6;
    
    // FWD = clockwise (positive rotation in SVG), REV = counter-clockwise (negative)
    const direction = demoState.bladeDirection === 'FWD' ? 1 : -1;
    
    // Update blade angle
    demoState.bladeAngle += degreesPerSecond * delta * direction;
    demoState.bladeAngle = demoState.bladeAngle % 360;
    
    // Apply rotation
    blades.setAttribute('transform', `rotate(${demoState.bladeAngle})`);
}

function pauseDemo() {
    demoState.playing = false;
    if (demoState.animationFrame) {
        cancelAnimationFrame(demoState.animationFrame);
        demoState.animationFrame = null;
    }
    const playIcon = document.getElementById('play-icon');
    if (playIcon) playIcon.textContent = '▶';
}

function togglePlayPause() {
    if (demoState.playing) {
        pauseDemo();
    } else {
        playDemo();
    }
}

function stopDemo() {
    pauseDemo();
    demoState.active = false;
    
    const pathGroup = document.getElementById('pattern-path');
    if (pathGroup) pathGroup.innerHTML = '';
    
    const circleGroup = document.getElementById('tool-circle');
    if (circleGroup) circleGroup.innerHTML = '';
    
    const coverageGroup = document.getElementById('coverage-trail');
    if (coverageGroup) coverageGroup.innerHTML = '';
    
    const timeline = document.getElementById('demo-timeline');
    if (timeline) timeline.classList.add('hidden');
}

// Auto-initialize when DOM is ready (if not already called)
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => {
        setupBedVisualization();
        setupDemoButtons();
    });
} else {
    // DOM already loaded, initialize now
    setupBedVisualization();
    setupDemoButtons();
}
</script>
